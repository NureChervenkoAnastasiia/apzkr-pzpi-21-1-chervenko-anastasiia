Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації керування закладами громадського харчування 


Студент гр. ПЗПІ-21-1                                           Червенко А.Д.		
                                                                 (підпис)
Керівник роботи                                                   доц. Лещинський В.О.
(підпис)

Робота захищено «_» _____2024р. 
	з оцінкою ____________________
 
Комісія:                                                                            доц. Лещинський В.О.
                         (підпис)
                                                                                                                доц. Лещинська І.О.
                         (підпис)
                                                                                                                ст. викл. Сокорчук І.П.
                         (підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук            Кафедра програмної інженерії                 
Спеціальність 121 – Інженерія програмного забезпечення                                   
Курс          3          Семестр                                  6                                                    -      
Навчальна дисципліна Архітектура програмного забезпечення                         -      

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

__________________Червенко Анастасії Дмитрівні______________________
1. Тема роботи: «Програмна система для автоматизованого керування закладами громадського харчування»                                                                -  
2. Термін узгодження завдання курсової роботи «11»   березня  2024 р. 
3. Термін здачі студентом закінченої роботи «10»    червня        2024 р.  
4. Вихідні дані до проєкту (роботи): Програмна система, призначена для автоматизації керування ресторанами. Завдяки системі у ресторанах повинна бути вагомо зменшена кількість роботи з обліку продуктів, обліку робочих та формування їх графіку роботи та зарплатні. Також оптимізовано процес комунікації між гостями ресторанів та працівників.  Дана система має бути масштабованою, орієнтованою на користувача, з інтуїтивно зрозумілим інтерфейсом. Повинна складатися з серверної частини, клієнтської частини та мобільного застосунку.                                                        
5. Зміст пояснювальної записки (перелік питань, що належить  розробити): аркуш завдання, аналіз предметної області, постановка задачі, опис прийнятих інженерних рішень серверної частини, опис методів обробки даних, програмний код серверної частини, опис прийнятих інженерних рішень клієнтської частини, програмний код клієнтської частини, опис прийнятих інженерних рішень мобільного застосунку, програмний код мобільного застосунку, посилання на папку "DEMO"                                        .
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма компонентів, UML діаграма станів, UML діаграма діяльності     .


КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітка
1	Функціональна специфікація програмного проекту	30.03.2024	виконано
2	Проектування програмного проекту	15.04.2024	виконано
3	Кодування програмного проекту	31.05.2024	виконано
4	Оформлення пояснювальної записки	06.06.2024	виконано
5	Захист курсової роботи	11.06.2024	виконано


Дата видачі завдання «   11   »        березня           2024 р.  


Керівник                                                                  доц. Лещинський В.О.
                                                                      (підпис)

Завдання прийняла до виконання 
ст. гр. ПЗПІ-21-1                                                                   Червенко А.Д.
    
                                                                                (підпис)
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 135 с., 91 рис, 3 табл.,10 додатки, 4 джерел.
АДМІНІСТРАТОР, БРОНЮВАННЯ, ВІДВІДУВАЧ, ЗАКЛАД ХАРЧУВАННЯ, ЗАМОВЛЕННЯ, КАФЕ, МЕНЮ, НАПОЇ, ПРАЦІВНИК, ПРОДУКТИ ХАРЧУВАННЯ, РОЗКЛАД, СТРАВИ.

Об’єктом дослідження є сфера громадського харчування, а саме складності роботи великої кількості процесів закладів громадського харчування, персоналізації досвіду відвідувачів, їх комунікації з працівниками та комунікації працівників між собою.
Метою курсової роботи є розробка програмної системи, що надає можливість керувати закладами громадського харчування, зменшити кількість робочих задач працівників шляхом автоматизації більшості задач, надати відвідувачам більше можливостей управління бронюваннями та особистими даними, надати працівникам можливості обліку харчових продуктів, керування меню закладу, замовлень, розкладу працівників та бронювань гостей. 
Методами розробки були обрані технології фреймворку ASP.NET Core на мові програмування C# для серверної частини, система управління нереляційними базами даних MongoDB для бази даних, мова програмування JavaScript з HTML та CSS для розробки вебзастосунку та мова програмування Kotlin для розробки мобільного застосунку у Android Studio.
У результаті виконання курсової роботи було розроблено систему автоматизації управління закладами громадського харчування, яка складається з сервера, вебзастосунку та мобільного застосунку.


ЗМІСТ


ВСТУП	8
1     АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	10
1.1	Бізнес-вимоги	10
1.1.1	Бізнес-можливості	10
1.1.2	Бізнес-цілі та критерії успіху	13
1.1.3	Потреби клієнтів або ринку	13
1.1.4	Бізнес-ризики	14
1.2	Концепція рішення	15
1.2.1	Окреслення концепції	15
1.2.2	Головна функціональність	17
1.2.3	Припущення та залежності	18
1.3	Рамки та обмеження проєкту	19
1.3.1	Рамки первинного випуску	19
1.3.2	Рамки наступних випусків	21
1.3.3	Обмеження та винятки	22
1.4	Бізнес-контекст	23
1.4.1	Профілі зацікавлених сторін	23
1.4.2	Пріорітети проєкту	24
1.4.3	Робоче середовище	25
2     КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ	26
3     ПРОЄКТУВАННЯ БАЗИ ДАНИХ	31
4     РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ	34
4.1	Структура та технології серверної частини програмної системи	34
4.2	Опис архітектури серверної частини програмної системи	36
4.3	Специфікація REST API	47
4.4	Тестування	51
5     РОЗРОБКА КЛІЄНТСЬКОЇ ЧАСТИНИ	52
5.1	Структура та технології клієнтської частини програмної системи	52
5.2	Архітектура клієнтської частини програмної системи	53
6	     РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ	56
6.1	Структура та технології мобільного застосунку програмної системи	56
6.2	Архітектура мобільного застосунку програмної системи	58
7	     ОПИС ПРОГРАМНОЇ СИСТЕМИ	60
7.1	Загальні відомості	60
7.2	Виклик і завантаження	61
7.3	Призначення і логічна структура	63
7.4	Опис програмної реалізації вебзастосунку	64
7.5	Опис програмної реалізації мобільного застосунку	94
8     ВИСНОВКИ	114
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	115
ДОДАТОК А Діаграми програмної системи	116
ДОДАТОК Б	121
Б.1 Код StaffService.cs, для роботи з колекціями працівників:	121
Б.2 Код Tables.js, для роботи зі столами закладу:	122
Б.3 Код BookingsActivity.kt:	125
Б.4 Код BookingsAdapter.kt:	129
Б.5 Код BookingsService.kt:	134


ВСТУП


Майже кожна людина у своєму житті хоч раз користувалася послугами кафе або ресторану. Проводити день народження, відмічати весілля чи просто святкувати будь-яке свято у закладі харчування стало для деяких людей навіть традицією. А дехто просто замість звичайного домашнього харчування та готування вдома віддає перевагу кафе та ресторанам.
Усі ці люди неминуче повинні були зіткнутися з проблемами бронювання столиків на певну дату та час, пошук інформації про страви та напої, наведені у меню кожного з закладів, взаємодії з офіціантами, аби вони передали інформацію про особисті вподобання у їжі кухарям, або ж скаргу до адміністрації закладу, тощо. В свою чергу для кожної з цієї задач кожен заклад потребує певну людину, яка буде виконувати свою задачу – офіціанти, кухарі, бармени, прибиральники, адміністратори, тощо. 
Наприклад, студент хоче відсвяткувати закінчення навчального року і зібратись із друзями у ресторані. Для цього йому буде необхідно знайти інформацію про ресторан, його контакти на подзвонити для броні столу. Адміністратор закладу у свою чергу повинен буде знайти вільний стіл на дату та час, які повідомив відвідувач. Після цього адміністратор повідомляє студенту, що вільне місце є, питає з приводу якихось зауважень та записує бронювання. І коли гості прийдуть до закладу, вони будуть повинні дочекатися офіціанта, щоб обрати страви та напої і зробити замовлення. Офіціант обов’язково буде повинен передати кухарям наявність певних побажань з приводу складу страви через смакові вподобання гостя або наявності алергії. 
Спеціальні програмні системи можуть вирішити ці проблеми завдяки автоматизації процесів та розділення відповідальності. Таким чином при існуванні програмної системи, студент міг просто завантажити застосунок, самостійно забронювати стіл на певну дату та час, одразу переглянути меню і за бажанням зробити попереднє замовлення, щоб не чекати на приготування свого замовлення. Робота офіціантів також буде значно спрощена до виносу страв та напоїв і прибирання столів. Додатково наявність особистих акаунтів у гостів дозволить впровадити систему бонусів, яка буде залучати гостей робити більше замовлень та частіше відвідувати заклад, аби отримати більше бонусів. А впровадження особистих акаунтів працівників дозволить чітко визначати їх робочий час для правильного нарахування заробітної плати. Це дозволить запобігти можливим помилкам через людський фактор та умисному збільшенні кількості відпрацьованих годин для отримання вигоди. 
Саме тому у закладах громадського харчування доцільно використовувати спеціальні програмні системи, що будуть спрощувати внутрішні процеси для працівників та відвідувачів, та зовнішні для власників. 
Головна мета програмної системи «Tastify» – допомогти закладам громадського харчування спростити та оптимізувати роботу усередині та їх відвідувачам спростити процес взаємодії з рестораном або кафе. Це дозволить зменшити навантаження з персоналу та навіть скоротити кількість людей, які повинні бути задіяні для коректного функціонування закладу. Водночас система дозволить власникам закладів більш доцільно аналізувати свій бізнес та приймати бізнес-рішення завдяки статистичним даним, які буде надавати програмна система «Tastify». Завдяки зручному онлайн-бронюванню, меню та системі замовлень «Tastify» може допомогти закладам збільшити обсяг продажів. Швидке та зручне обслуговування завдяки онлайн-замовленням, системі управління чергами та програмі лояльності може значно покращити досвід клієнтів. Також програмна система дозволить зменшити кількість витрат на персонал завдяки автоматизації багатьох рутинних завдань. 
Використання програмної системи "Tastify", може допомогти закладам громадського харчування залишатися цілковито  конкурентоспроможними на ринку.


1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес-можливості 


Наразі існує досить багато програмних продуктів, які створені для прощення керування роботою у закладах громадського харчування. Але всі вони мають свої слабкі та сильні сторони. Тому для аналізу були обрані дві популярні наразі системи – це «Poster POS» та «Toast».
Спочатку розглянемо «Poster POS». Це програмна система українського походження, яка позиціонує себе як система, яка повністю бере на себе всі складності, які виникають у роботі будь-якого закладу, а саме: роботу з терміналом та мобільною касою, складський облік, збір та обробку аналітичних даних, відображення та змінення меню, фінансові та маркетингові дані та спеціальні можливості роботи з ними. 
Також створені доповнення до цієї системи: застосунок для власника («Poster Boss»), QR-меню, оплата та відгуки («Poster QR»), керування мережею закладів чи франшизою («Poster Connect»), екран на кухню («Kitchen Kit») а також сайт для замовлень. Poster POS пропонує рішення для різних типів бізнесу: ресторани, пекарні, кондитерські, заклади швидкого харчування, бари, кав’ярні, їдальні, паби, тощо. З автоматизації роботи у системі наявні можливості з доставлення їжі, для запуску власних доставок з кожного закладу. Програмне забезпечення підтримує наступні мови: російська, українська, англійська, іспанська, грузинська, естонська та узбецька. 
Перейдемо до переваг даної системи:
	інтуїтивно зрозумілий інтерфейс, що буде простим для навчання;
	збереження усіх даних у хмарному сервісі, що надає доступ до даних у будь-якій точці світу, де є підключення до інтернету;
	широкий функціонал, що окрім вирішення складностей з кухнею охоплює й роботу з аналітичними та фінансовими даними;
	адаптація як під український ринок, так і під іноземні бізнеси;
	цілодобова онлайн-підтримка спеціалістів;
	підтримка роботи з багатьма видами операційних систем та додаткового обладнання, як термальні принтери та фіскальні реєстратори;
	безкоштовний пробний період на 15 днів.
Також у системі були виявлені певні недоліки:
	обмежена масштабованість для великих ресторанів або мережевих закладів;
	складності з інтеграцією з іншими системами;
	залежність від інтернет-з’єднання та можливість втрати даних за його відсутності.
Проаналізувавши цей аналог робимо висновок, що головними перевагами системи «Poster POS» є широкий функціонал, простий та приємний інтерфейс та підтримка роботи з декількома видами операційних систем для яких розроблені окремі додаткові застосунки. 
Тепер розглянемо друге програмне забезпечення для керування закладами громадського харчування «Toast». Як і у попередній системі, вона дозволяє працювати з багатьма типами закладів. Але на відміну від попереднього аналога вона має окремий функціонал для ресторанів при готелях. З головного функціоналу можна виділити бронювання столів, подарункові картки, управління персоналом та їх розкладом, онлайн замовлення з доставкою та попередні замовлення з оплатою, інтеграції з іншими сервісами доставки, підтримка у організації святкових подій, система для відображення замовлень на кухні та аналітичне дослідження роботи закладів. 
Перейдемо до переваг даної системи:
	великий обсяг доступних функцій;
	гнучкість та можливість налаштування системи під конкретні потреби кожного бізнесу;
	зручний та зрозумілий інтерфейс;
	офлайн-збереження даних на пристрої при відсутності інтернет-з’єднання;
	проста інтеграція з іншими системами;
	онлайн-підтримка технічних спеціалістів.
Також у системі були виявлені певні недоліки:
	висока вартість системи;
	відсутня клієнтська частина для відвідувачів закладів.
Проаналізувавши цей аналог робимо висновок, що перевагою системи також можуть слугувати гнучкість та надійність системи. Також вагомою перевагою буде клієнтська частина для відвідувачів для броні місць, попередні замовлення страв та напоїв. 
Детально дослідивши ці два програмних продукти можна зробити висновок, що вони мають дуже широкий функціонал, але мають низку недоліків. Таким чином найсильніша перевага «Tastify» над розглянутими аналогами у тому, що продукт буде використаний не лише адміністраторами та власниками закладів, а ще й відвідувачами, що відповідно також покращить швидкість роботи ресторану та зменшить обсяг роботи офіціантів. Додатково «Tastify» буде мати широкий функціонал і гнучкий та зрозумілий інтерфейс.
Програмний продукт має усі перспективи щодо монетизації шляхом надання доступу до системи новим закладам, підключення їх до бази даних та серверу. Тож заклади громадського харчування повинні будуть платити за доступ до системи та збереження їхніх даних кожен місяць або ж обрати інший тариф та оплатити одразу за 3 місяця чи за 1 рік. Рекомендовані наступні тарифні плани: безкоштовний – пробний період на 1 місяць, стандартний – доступ до всіх основних функцій, базове управління даними, преміум – доступ до усіх функцій, детальне відстеження даних, аналітика, API-інтеграція. 
Також будуть надаватися додаткові послуги: допомога з впровадженням та використанням системи, інтеграція з іншими системами,  допомога з просуванням закладу та залученням клієнтів. Для поширення популярності системи буде здійснюватися проведення демонстрацій системи для потенційних клієнтів та співпраця з іншими компаніями в сфері ресторанного бізнесу. Проект є дуже перспективним, оскільки люди їдять кожен день і завжди будуть їсти. Тому все більше і більше закладів харчування будуть потребувати програмну систему подібну до «Tastify».


1.1.2	Бізнес-цілі та критерії успіху


БЦ-1: Зменшити робоче навантаження адміністраторів, офіціантів та кухарів закладів харчування;
БЦ-2: Збільшити кількість клієнтів, яких може обслугувати заклад харчування шляхом пришвидшення їх комунікації з обслуговуючим персоналом;
БЦ-3: Ефективно та чітко вести облік продуктів харчування;
БЦ-4: Просто та швидко здійснювати бронювання столів та попереднє замовлення страв та напоїв;
БЦ-5: Підвищити задоволеність відвідувачів закладів завдяки зручностям мобільного застосунку та покращеного рівня обслуговування;
БЦ-6: Покращити репутацію закладів громадського харчування;
БЦ-7: Збільшити мотивацію працівників системою бонусів;
БЦ-8: Забезпечити більш ефективне та автономне управління харчовими продуктами, що дозволить знизити витрати та оптимізувати робочий процес;
КУ-1: Збільшення кількості бронювання столів онлайн на 60%;
КУ-2: Збільшення кількості завантажень застосунку на 20% в рік;
КУ-3: Зменшення часу очікування на страви та напої на 70% у порівнянні з звичайними замовленнями безпосередньо у закладі;
КУ-4: Співпраця мінімум з 2 клієнтами (закладами громадського харчування) після випуску продукту.


1.1.3	Потреби клієнтів або ринку


Ринок потребує створення повноцінної системи для відвідувачів закладів громадського харчування і власне для самих закладів. Оскільки наявні зараз системи близькі за функціоналом до не можуть впоратися з усіма потрібними функціями, тож це перекладається на працівників що зменшує продуктивність роботи. Заклади громадського харчування можуть обслуговувати більше людей і робити це більш якісно, ніж за відсутності подібної системи. Додатковим плюсом стане поліпшений алгоритм обліку харчових продуктів та аналізу статистичних даних з роботи закладів. Співробітники будуть більш вмотивовані у якісному та швидкому виконанні роботи через систему бонусів. Також вони будуть захищені від професійного вигорання, оскільки система значно зменшить кількість інформації з якою вони будуть повинні працювати щодня. А власники закладів зможуть бачити реальну ситуацію у своїх  закладах та аналізувати їх статистичні дані з доходів та витрат. Тому даний програмний продукт буде дуже популярний на ринку завдяки вирішенню ще невирішених питань.


1.1.4	Бізнес-ризики


Проаналізувавши ринок, було виявлено що існує велика конкуренція, що викликає наступні бізнес-ризики: 
1.	На початку запуску проекту може бути складно знайти перших користувачів, бо майже всі існуючі заклади громадського вже користуються певним програмним забезпеченням до якого звикли і прилаштувалися. Тому слід розробити сильну маркетингову компанію та презентацію застосунку, як заміни вже існуючим; 
2.	Збільшення кількості цифрових даних може збільшити ризик несанкціонованого доступу або витоку. Тому важливо використовувати сучасні та надійні методи зберігання та захисту конфіденційних даних; 
3.	Інші системи можуть з часом зробити подібні рішення, тож слід постійно оновлювати і вдосконалювати продукт;
4.	Розробка і підтримка програмного продукту може вимагати більших фінансових вкладень, ніж які потім будуть вилучені. Тож слід обережно керувати бюджетом.


1.2	Концепція рішення
1.2.1	Окреслення концепції


Програмний продукт «Tastify» – це система, що дозволить повністю керувати усіма процесами закладів громадського харчування починаючи від обліку продуктів харчування до страв та напоїв та закінчуючи бронюванням столів та попереднім замовленням страв гостями. Для участі у бонусній програмі, відвідувачі будуть повинні зробити особистий акаунт у мобільному застосунку. Відповідно у мобільному застосунку відвідувачі будуть мати змогу переглянути меню закладу, інформацію про кожне блюдо. Також вони зможуть керувати своїми бронюваннями – створювати нові, редагувати та видаляти вже наявні. Адміністратори зможуть мати доступ до обліку харчових продуктів, бронюванню столів, меню закладу, замовлень відвідувачів, статистичних звітів, списку працівників, та інформації про них.  Кухарі, бармени, офіціанти та інші працівники будуть мати доступ до замовлень, столів, меню, свого профілю та розкладу. Таким чином кухарі та бармени зможуть напряму отримувати замовлення від клієнтів, без участі офіціантів. А офіціанти будуть повинні лише винести блюдо та столові прилади. 
Усі робітники можуть самостійно позначати початок і кінець робочого дня для справедливого нарахування зарплатні, бо у закладах громадського харчування у працівників дуже часто ненормований графік роботи. Адміністратори  будуть мати доступ до статистичних звітів, що дозволить аналізувати популярність страв та напоїв, працьовитість персоналу закладу. Також чіткі підрахунки витрат та доходів системою дозволить виключити людський фактор (зробить неможливими випадкові помилки у розрахунках та цілеспрямовані крадіжки грошей).
Відвідувачі закладів громадського харчування, що використовують програмну систему будуть мати доступ до участі у програмі лояльності, яка буде надавати певні бали за замовлення, які потам можна виміняти на купон, що буде працювати як знижка на наступне замовлення.
Таким чином автоматизація багатьох рутинних завдань, таких як прийняття замовлень, ведення обліку призведе до значного зменшення навантаження на працівників у кожному закладі та витрати на їх заробітні плати. Відвідувачам буде легше і швидше бронювати столи та робити замовлення. Швидке та зручне обслуговування завдяки онлайн-бронюванню, меню та системі замовлень покращить клієнтський досвід з закладом громадського харчування та залишить гарні спогади, що призведе до повернення клієнтів знов. Можливість для закладів пропонувати нові послуги, такі як онлайн-замовлення та доставка зможуть збільшити прибутки. 
Було відокремлено головні переваги програмної системи «Tastify»:
	комплексне рішення для керування всіма аспектами роботи закладів громадського харчування, від бронювання столів до аналітики даних;
	можливість інтегрування з іншими системами, такими як системи обліку, CRM-системи та служби доставки;
	можливість налаштування системи відповідно до потреб кожного закладу;
	інтуїтивно зрозумілий інтерфейс, який легко використовувати як персоналу, так і клієнтам;
	оптимізація робочих задач власників та менеджерів закладів дозволяє оптимізувати роботу, покращити обслуговування клієнтів та збільшити прибуток;
	автоматизація рутинних завдань.
Таким чином «Tastify» покращить життя кожної людини, життя якої перетинається з закладами громадського харчування, які використовують цю програмну систему.


1.2.2	Головна функціональність


Зі сторони вебзастосунку:
ГФ-1: Вхід до системи працівниками закладу;
ГФ-2: Перегляд облікової інформації про кількість наявних харчових продуктів, зміна їх кількості;
ГФ-3: Перегляд заброньованих столів, їх зміна;
ГФ-4: Перегляд інформації про відвідувачів закладів;
ГФ-5: Перегляд списку замовлених страв та напоїв, зміна статусу замовлення;
ГФ-6: Перегляд інформації про заклад, до якого відноситься авторизований працівник;
ГФ-7: Перегляд інформації про заклад, до якого відноситься авторизований працівник;
ГФ-8: Перегляд інформації про розклад роботи персоналу закладу;
ГФ-9: Перегляд та управління даними про харчові продукти у наявності у закладі;
ГФ-10: Перегляд статистичних даних з роботи закладу;
ГФ-11: Зміна мови на сайті;
ГФ-12: Керування резервними копіями бази даних;
ГФ-13: Перегляд меню закладу, можливість додавання, редагування та видалення страв та напоїв;
ГФ-14: Перегляд списку працівників, інформації про них, редагування цієї інформації, додавання нових працівників.
Зі сторони мобільного застосунку:
ГФ-15: Реєстрація та вхід до системи відвідувачами;
ГФ-16: Перегляд меню закладу, інформації про кожну страву та напій;
ГФ-17: Перегляд та зміна особистого акаунту;
ГФ-18: Перегляд доступних дат, часу та столів для бронювання;
ГФ-19: Бронювання певного столу на визначену дату та час;
ГФ-20: Зміна інформації про бронювання;
ГФ-21: Відміна бронювання столу;
ГФ-22: Зміна мови застосунку;
ГФ-23: Перегляд бонусів та формування купонів на знижку.


1.2.3	Припущення та залежності


П-1: Припускається, що система буде збирати персональні дані відвідувачів та працівників закладів громадського харчування.
П-2: Припускається, що користувачам мобільного застосунку легше та приємніше забронювати стіл у закладі, ніж зателефонувавши по телефону або вже власне у закладі (може не виявитись вільних столів).
П-3: Припускається, що система буде вести облік харчових продуктів.
П-4: Припускається, що система буде вимушена зберігати велику кількість даних для кожного закладу.
П-5: Припускається, що мобільний додаток буде доступний на популярних мобільних платформах.
П-6: Припускається, що користувачі системи будуть мати постійний доступ до інтернету.
З-1: Для безпечного зберігання даних користувачей система повинна бути розроблена з огляду на найновіші та найкращі методи захисту персональної інформації.
З-2: Потрібно дуже обережно та чітко працювати з кількістю наявних харчових продуктів, їх терміном придатності, якістю та кількістю (для запобігання крадіжок, отруєнь та закінчення продуктів).
З-3: Мобільний застосунок має бути дуже зручним, приємним візуально та інтуїтивно зрозумілим для користувачів.
З-4: Система повинна буди масштабованою.
З-5: Застосунок обов’язково має бути розміщеним на популярних мобільних платформах.
З-6: Для коректної роботи системи необхідний сталий доступ до інтернету.


1.3	Рамки та обмеження проєкту
1.3.1	Рамки первинного випуску


З огляду на план створення програмного продукту були розроблені рамки первинного випуску. Вони будуть окремі для кожної частини проекту. 
У серверній частині необхідно реалізувати наступний функціонал:
	вхід до системи (авторизація та реєстрація) за ролями і різними правами для користувачів з різними ролями;
	створення, редагування та видалення інформації про певне бронювання;
	редагування та видалення інформації про гостей;
	створення, редагування та видалення інформації про усі страви меню закладів;
	створення, редагування та видалення інформації про бронювання певного відвідувача;
	підрахунок та отримання статистичних даних з кількості замовлень для найпопулярніших страв та напоїв;
	створення, редагування та видалення інформації про замовлення;
	створення, редагування та видалення інформації про продукти;
	створення, редагування та видалення інформації про ресторани;
	створення, редагування інформації про розклад працівників;
	підрахунок та отримання кількості відпрацьованих годин кожним працівником за певний тиждень;
	створення, редагування та видалення інформації про працівників;
	створення, редагування та видалення інформації про столи.
У вебзастосунку необхідно реалізувати наступний функціонал:
	вхід до системи (авторизація);
	перегляд та зміна інформації про наявні харчові продукти, сортування за кількістю по зростанню та спаданню, алфавітним порядком та навпаки;
	перегляд та зміна інформації про бронювання (збереження локального часу повинно бути записано у базу даних в універсальному форматі, а відображення універсального часу повинно бути у локальному часу користувача);
	перегляд та зміна інформації про страви та напої у меню ресторану, статистику з популярності їх замовлень, фільтрація для відображення лише напоїв, лише перших страв чи лише других страв;
	перегляд та редагування інформації про працівників, їх графіку роботи та статистики з кількості відпрацьованих годин по тижням (збереження локального часу повинно бути записано у базу даних в універсальному форматі, а відображення універсального часу повинно бути у локальному часу користувача);
	перегляд та зміна інформації про замовлення;
	створення резервних копій бази даних, отримання усіх доступних резервних копій бази даних за їх датою та часом створення, її відновлення по вже існуючій копії;
	перегляд та зміна інформації про столи у закладі;
	перегляд інформації про ресторан;
	зміна мови інтерфейсу (українська/англійська).
У мобільному застосунку необхідно реалізувати наступний функціонал:
	вхід до системи (авторизація);
	реєстрація у системі для нових користувачів;
	перегляд та зміна особистої інформації відвідувача;
	створення нових бронювань на певну дату, час, кількість людей та стіл (збереження локального часу повинно бути записано у базу даних в універсальному форматі);
	перегляд та зміна та видалення інформації про бронювання відвідувача (відображення універсального часу повинно бути у локальному часу користувача);
	перегляд меню ресторану з усією інформацією про страви та напої з меню закладу;
	перегляд кількості персональних бонусів, перетворення їх на купон (після створення купону повинна оновлюватися кількість бонусів та виводитися повідомлення про суму, на скільки менше може сплатити користувач за своє замовлення).


1.3.2	Рамки наступних випусків


Наступні випуски системи можуть містити наступний функціонал:
	розширення підтримки різних мір для вимірювання розмірів порцій страв та напоїв;
	інтеграція вже з існуючими системами інших виробників працюючих закладів громадського харчування;
	збереження даних щодо переліку алергенів відвідувачів та аналіз блюд з меню на наявність цих складових;
	розробка окремого інтерфейсу для замовлень на доставку та інтеграція з застосунками компаній, які спеціалізуються на доставці приготовленої їжі з закладів громадського харчування;
	розробка окремого інтерфейсу для попередніх замовлень страв та напоїв перед відвідуванням закладу, щоб відвідувачі не повинні були чекати на їх приготування;
	розробка окремого інтерфейсу для електронної книги відгуків про заклади безпосередньо у мобільному застосунку;
	підключення датчиків IoT для відмічання робочих годин працівників прикладанням особистої картки до цих датчиків;
	можливість оплати замовлень прямо у мобільному застосунку.


1.3.3	Обмеження та винятки


Система має низку обмежень та винятків:
	система вимагає постійного інтернет підключення для коректної роботи застосунків;
	людина не може отримати бонуси, якщо вона не зареєстрована у застосунку;
	не може бути використано у приготуванні страв чи напоїв в закладі жоден продукт харчування, якого нема у системі;
	при замовленні алкогольних напоїв, для підтвердження віку відвідувача буде викликано офіціанта, при попередньому замовлення алкогольних напоїв чи замовленню на доставку, для підтвердження віку замовника при видачі будуть перевірені документи;
	якщо офіціант не підтвердить досягнення 18 років людиною, яка замовила алкогольний напій, його буде видалено з замовлення;
	відвідувачам може бути відмовлено в обслуговуванні, навіть якщо у застосунку ще є вільні місця, за умови що усі столи у закладі громадського харчування зайняті 
	відвідувачам може бути відмовлено у страві чи напої якщо відсутні продукти для замовленої позиції.


1.4	Бізнес-контекст
1.4.1	Профілі зацікавлених сторін


Таблиця 1.1 – Профілі зацікавлених сторін
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
Власники закладів громадського харчування	Отримання більшого прибутку	Дивиться на продукт, як на свою можливість підвищити ефективність роботи закладу, збільшивши прибутки та зменшивши витрати а також як на можливість покращити репутацію та популярність усіх своїх закладів 	Вартість системи, час залучення системи у роботу закладу, час та вартість навчання персоналу, час на досягнення перших результатів, витрати на додаткове обладнання	Бюджет
Адміністратори закладів громадського харчування	Спрощення обліку харчових продуктів, зняття задач контролю графіку роботи персоналу, бронювання столів та попередні замовлення	Дивиться на продукт, як на можливість спростити свою роботу	Навчитися працювати з системою для найшвидшого спрощення задач роботи	Навчитися працювати з системою (час та складність)


Продовження таблиці 1.1
Працівники закладів громадського харчування (кухарі та офіціанти)	Спрощення отримання замовлень офіціантами та передачі їх на кухню, формування меню та обліку продуктів	Дивиться на продукт, як на можливість спростити свою роботу	Навчитися працювати з системою для найшвидшого спрощення задач роботи	Навчитися працювати з системою (час та складність)
Відвідувачі закладів громадського харчування	Спрощення бронювання столів, система накопичення бонусів. Перегляд меню та детальної інформації про кожну страву та напій	Дивиться на продукт, як на можливість полегшення свого життя та покращення свого досвіду відвідування закладів громадського харчування	Швидкий доступ до системи бронювання, перегляду страв та напоїв. Накопичення та використання персональних бонусів. 	Смартфон для застосунку, навчитися працювати з ним


1.4.2	Пріорітети проєкту


Таблиця 1.2 – Пріоритети проекту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Випуск 1.0 стане доступним до 10.06.2023,
Випуск 1.1 – до 10.07.2023		


Продовження таблиці 1.2
Функціональність			80% функцій із високим пріоритетом мають бути включені до випуску 1.0
Якість			У випуску 1.0 повинні пройти 90-95% тестів, у випуску 1.1 – 95-98%
Персонал		Лише один розробник повинен працювати над проектом	
Ціна			Допустимо перевищити бюджет на 10% без перегляду робіт


1.4.3	Робоче середовище


Back-end буде написано мовою C# за допомогою ASP.NET. Для бази даних буде використовуватися система управління базами даних MongoDB. Тому, що C# є популярною мовою для розробки back-end додатків, особливо в середовищі .NET. Ця мова пропонує багато функціональних можливостей і зручність розробки. ASP.NET - це фреймворк для розробки вебзастосунків на C#, який надає засоби для створення вебсерверів, що ідеально підходить для MongoDB. MongoDB відомий своєю гнучкістю схеми, швидкістю розробки та масштабованості, що буде важливо у проєкті, бо структура може змінюватися залежно від потреб бізнесу(ресторани, пекарні, бари, тощо) [1].
Front-end буде написаний за допомогою HTML, CSS, JavaScript. Бо використання HTML, CSS та JavaScript є стандартом для веброзробки. Вони підтримуються сучасними браузерами та забезпечують інтерактивність та дизайн. 
Mobile буде написаний на мові Kotlin. Бо Kotlin – це сучасна та популярна мова програмування, яка створена спеціально для розробки Android-застосунків. 


2	КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ


Перед розробкою серверної частини необхідно чітко визначити та детально описати усі необхідні для реалізації визначеного функціоналу сутності. Тому для визначення усіх необхідних сутностей та зв’язків між ними, для системи була створена ER-діаграма (див. рис. 2.1).

 
Рисунок 2.1 – ER-діаграма програмної системи «Tastify»

Модель даних охоплює наступні компоненти та відповідні атрибути для них:
а) Ресторан (назва, адреса, номер телефону, електрона пошта, опис, кухня);
б) Меню (ресторан, назва страви чи напою, розмір порції, ціна, опис, тип);
в) Працівник ресторану (ім’я, посада, погодинна заробітна плата, номер телефону, код картки відвідування, логін, пароль, ресторан);
г) Розклад (працівник, дата та час початку зміни, дата та час кінця зміни);
д) Продукт (назва, поточна кількість у наявності);
е) Замовлення (номер, стіл, дата та час, коментар, статус).
ж) Стіл (номер, статус);
к) Бронювання (стіл, гість, дата та час, кількість гостей, коментар);
л) Гість (ім’я, номер телефону, кількість бонусів, логін, електрона пошта, пароль).
Кожна сутність має визначені поля для найефективнішої реалізації  запланованого функціоналу системи. Додатково додані спеціальні поля для зберігання коментарів співробітників про вподобання гостей, статуси столів та замовлень. Це зроблено з метою відстеження завантаженості закладів адміністраторами, етапів приготування їжі кухарями та етапів закриття рахунку за замовлення працівниками закладу.
Після визначення сутностей та їх атрибутів, слід перейти до дослідження можливих сценаріїв використання програмної системи користувачами. Тож для визначення цих сценаріїв було розроблено UML діаграми прецедентів для кожного з акторів, а саме для відвідувача, працівника та адміністратора закладу громадського харчування. Розглянемо детально функціонал, доступний кожному з перелічених акторів.
UML діаграму прецедентів для гостей закладів громадського харчування наведено на рисунку 2.2. Відвідувач закладів громадського харчування має доступ лише до мобільного застосунку програмної системи «Tastify». Там у нього є можливість зареєструватися чи увійти за допомогою логіну та пароля у вже існуючий акаунт. Лише після авторизації, користувач отримує доступ до усього іншого функціоналу застосунку. При реєстрації нового користувача, йому буде необхідно ввести усі необхідні особисті дані про себе і авторизуватися у системі. Авторизований користувач може переглядати введену раніше особисту інформацію та за необхідністю змінювати її. Таким чином шляхом редагування особистої інформації, заданої під час реєстрації користувач може змінити інформацію про себе. Після авторизації, користувач може переглянути інформацію про усі наявні страви та напої у меню закладу громадського харчування. Таким чином користувач може обрати позиції з меню, які він хоче замовити. Відвідувач може створити нове бронювання стола у певному ресторані на певний час, переглянути список усіх своїх бронювань, редагувати та видаляти заплановані. Також кожен користувач за відвідування закладу та замовлення у ньому накопичує бонусні бали, які можуть бути конвертовані у знижку на наступне замовлення. Він може переглянути кількість балів та конвертувати бали у купон на знижку у своєму особистому профілі.

 Рисунок 2.2 – UML діаграма прецедентів з актором відвідувача закладу громадського харчування програмної системи «Tastify»

UML діаграму прецедентів для працівників закладів громадського харчування наведено на рисунку 2.3. Працівник закладу має доступ лише до вебзастосунку програмної системи «Tastify». Там він може авторизуватися, увійшовши у свій особистий акаунт за допомогою логіну та паролю. Лише після цього користувачу буде надано доступ до усього іншого функціоналу. Працівник закладу може переглядати меню закладу, графік роботи, відкривати та закривати свою зміну. Додатково можливо переглянути та змінити інформацію про столи у закладі громадського харчування та інформацію замовлення певних відвідувачів. Також він може подивитися свою особисту інформацію у системі та за необхідністю змінити її. 

 
Рисунок 2.3 – UML діаграма прецедентів з актором працівника закладу громадського харчування програмної системи «Tastify»

UML діаграму прецедентів для адміністраторів системи закладів громадського харчування наведено на рисунку 2.4. Адміністратор також має доступ лише до вебзастосунку. Для початку роботи він так само повинен авторизуватися у системі, увійшовши за допомогою свого логіну та паролю. Після чого він може перейти до безпосередньої роботи з функціоналом системи. Адміністратор може переглянути список усіх працівників закладу, додати чи видалити працівника та змінити особисту інформацію про нього. Так само адміністратор може додати, видалити та редагувати наявні харчові продукти, страви та напої у меню закладу, гостей, столи та замовлення. Також адміністратор може отримати та змінити інформацію про графік роботи усіх працівників. А також отримати звіт за тиждень з кількістю відпрацьованих годин кожним працівником у порядку спадання. Він може переглянути інформацію про усі бронювання, змінити інформацію про них, додавати нові бронювання та видаляти вже існуючі. Додатковими можливостями є отримання статистики замовлень страв та напоїв у ресторані для відстеження кількості замовлень для кожної позиції меню конкретного ресторану і популярності цих самих страв та напоїв. Також адміністратор має можливість створення резервних копій бази даних та відновлення бази даних за певною резервною копією за її датою.

Рисунок 2.4 – UML діаграма прецедентів з актором адміністратора закладу громадського харчування програмної системи «Tastify»

Після завершення концептуального моделювання предметної області було визначено основні сутності програмної системи автоматизації управління закладів громадського харчування «Tastify» та розроблено ER-діаграму та UML діаграму прецедентів для усіх користувачів системи. Наступним кроком можна розпочинати реалізацію інженерних рішень. 
3	ПРОЄКТУВАННЯ БАЗИ ДАНИХ


За результатами концептуального моделювання предметної області було визначено основні сутності та зв’язки між ними. Для розробки бази даних необхідно побудувати логічну модель бази даних, спираючись на отримані раніше дані. Слід виділити необхідні колекції та атрибути, усунути зв'язок «багато-до-багатьох», додати первинні та зовнішні ключі. 
Спочатку було визначено додаткові таблиці для страв і напоїв у певному замовленні та продуктів у стравах та напоях для перетворення зв’язку «багато-до-багатьох» на зв'язок «один-до-багатьох». Для побудови логічної моделі бази даних було виділено наступні сутності:
	бронювання (Bookings);
	відвідувачі (Guests);
	меню (Menu);
	замовлення (Orders);
	позиції у замовленні(Order_items);
	продукти (Products);
	продукти у позиції (Position_products);
	заклади громадського харчування (Restaurants);
	розклад (Schedule);
	працівники (Staff);
	столи (Tables).
Колекція Bookings буде містити у собі первинний ключ (_id), дату та час бронювання (date_time), кількість відвідувачів (persons), коментар до бронювання (comment), зовнішні ключі до колекції Tables (table_id) та колекції Guests (guest_id), який здійснює бронювання. 
Колекція Guests буде містити у собі первинний ключ (_id), повне ім’я відвідувача (name), номер мобільного телефону (mobile_number), кількість бонусів (bonus), адресу електронної пошти (email), хеш паролю (password_hash), логін (login).
Колекція Menu буде містити у собі первинний ключ (_id), назву позиції (name), розмір порції (size), ціну (price), опис позиції (info), тип позиції (type), зовнішній ключ до колекції Reatsurants (restaurant_id).
Колекція Order_items буде містити у собі первинний ключ (_id), зовнішній ключ до колекції Menu (menu_id), зовнішній ключ до колекції Orders (order_id), кількість саме цієї страви або напої у замовленні (amount).
Колекція Orders буде містити у собі первинний ключ (_id), номер замовлення (number), дату та час замовлення (date_time), коментар до замовлення (comment), статус замовлення (status) та зовнішній ключ до колекції Table (table_id).
Колекція Position_products буде містити у собі первинний ключ (_id), зовнішній ключ до колекції Menu (menu_id) та до колекції Products (product_id).
Колекція Products буде містити у собі первинний ключ (_id), назву харчового продукту (name) та його кількість у наявності (amount).
Колекція Restaurants буде містити у собі первинний ключ (_id), назву закладу громадського харчування (name), його адресу (address), контактний номер телефону (telephone), адресу електронної пошти (email), інформацію про ресторан (info) та вид кухні, страви якої готують у закладі (cuisine).
Колекція Schedule буде містити у собі первинний ключ (_id), дату та час початку робочої зміни (start_date_time), дату та час завершення робочої зміни (finish_date_time), зовнішній ключ до таблиці Staff (staff_id).
Колекція Staff буде містити у собі первинний ключ (_id), повне імя працівника закладу (name), його посаду (position), погодинну зарплатню (hourly_salary), номер мобільного телефону (mobile_number), номер картки відвідування (attendance_card), логін (login), хеш паролю (password_hash), зовнішній ключ до колекції Restaurants (restaurant_id).
Колекція Tables буде містити у собі первинний ключ (_id), номер столу (number), статус столу (status).
За отриманою інформацією було створено базу даних TastifyDB у системі управління базами даних MongoDB. Для візуалізації логічну модель бази даних наведено на рисунку 3.1.

 
Рисунок 3.1 – Логічна модель бази даних TastifyDB програмної системи «Tastify»

На цьому етапі ми завершили проектування бази даних. Тепер можна переходити безпосередньо до створення серверної частини застосунку для роботи з базою даних.


4	РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ
4.1	Структура та технології серверної частини програмної системи


Вибір технологій для розробки серверної частини програмної системи був обґрунтований функціональними вимогами визначеної системи та досвідом розробки у минулих проєктах. Таким чином, була обрана платформа .NET 8 для написання серверної частини. А саме платформа ASP.NET Core, яка забезпечує гнучкість, широкі можливості, продуктивність і сучасні можливості для розробки вебзастосунків [2]. В ASP.NET Core були створені контролери для RESTful вебсервісів, які взаємодіють за принципами архітектурного стилю REST. 
Системою управління баз даних була обрана MongoDB, бо вона відрізняється гнучкістю, масштабованістю та високою продуктивністю. MongoDB зберігає дані у форматі BSON (бінарний JSON), що дозволяє зберігати документи різної структури та легко змінювати схему даних у процесі розробки. Також MongoDB підтримує шардінг, що дозволяє розподіляти дані на кілька серверів, забезпечуючи високу доступність та масштабованість та складні індекси, які підвищують швидкість запитів до бази даних. Існує добре підтримуваний офіційний драйвер MongoDB для C#, який легко інтегрується з проектами на .NET 8 ASP.NET Core, забезпечуючи простий доступ до всіх функціональних можливостей MongoDB і додатково існує багато бібліотек, які полегшують інтеграцію з ASP.NET Core, включаючи інструменти для керування підключенням, обробки даних і виконання запитів [1]. 
Комунікація між сервером та клієнтською частиною здійснюється за допомогою використання REST API, бо він забезпечує простоту, гнучкість та стандартизацію взаємодії між клієнтами та серверами за допомогою стандартних HTTP-методів, сприяючи легкій інтеграції та ефективному обміну даними у розподілених системах. Також підтримує робота з форматом даних JSON. Більше детально розглянути взаємодію серверної частини з іншими елементами системи можна на UML діаграмі розгортання (див. рис. 4.1).
 
Рисунок 4.1 – UML діаграма розгортання програмної системи «Tastify»

Була визначена необхідність змоделювати поведінку об'єктів системи у відповідь на різні події для того щоб визначити, як об'єкт переходить від одного стану до іншого при настанні певних умов. Тому було вирішено розробити діаграму станів для кожного з акторів системи (див. рис. А.1 у додатку А для адміністратора системи,  рис. А.2 у додатку А для працівника закладу громадського харчування та рис. А.3 у додатку А для відвідувача закладу). Діаграми були використані для полегшення розуміння системи або моделі, структури та поведінки. Також діаграми були використані під час аналізу та проєктування системи для ідентифікації ключових станів об'єктів і визначення можливих переходів між ними. Такі дії допомагають уникнути непередбачених ситуацій та розробити доцільний дизайн.


4.2	Опис архітектури серверної частини програмної системи


Проєкт складається з кількох ключових компонентів, організованих за принципами багатошарової архітектури, що забезпечує чітке розділення обов'язків та сприяє легкій підтримці й масштабуванню. Контролери обробляють HTTP-запити від клієнтів і повертають відповідні HTTP-відповіді. Вони відповідають за маршрутизацію запитів до відповідних сервісів. Загалом було розроблено десять контролерів: BackupController.cs, BookingController.cs, GuestController.cs, MenuController.cs, OrderController.cs, ProductController.cs, RestaurantController.cs, ScheduleController.cs, StaffController.cs та TableController.cs. Приклад методу з контролеру BookingController.cs:
1	[Authorize(Roles = Roles.Worker + "," + Roles.Administrator)]
2	[HttpGet]
3	public async Task<ActionResult<List<BookingDto>>> GetAllBookings()
4	{
5	try
6	{
7	     var bookings = await _bookingService.GetAsync();
8	     var bookingDtos = _mapper.Map<List<BookingDto>>(bookings);
9	     return Ok(bookingDtos);
10	}
11	catch (Exception ex)
12	{
13	     _logger.LogError(ex, "Failed to get all bookings");
14	     return StatusCode(500, "Failed to get all bookings");
15	}
16	}
Як бачимо, перш за все перед методом вказані ролі, які можуть його викликати (див. рядок 1). Коли користувач відправляє запит, цей атрибут перевіряє його роль. Якщо роль користувача не відповідає жодній з дозволених ролей, запит відхиляється з помилкою доступу. Таким чином отримати список усіх бронювань може лише робітник закладу та адміністратор. Потім вказано атрибут, який визначає який HTTP-запит буде виконувати метод  (див. рядок 2). Коли сервер отримує GET-запит до цього маршруту, він викликає цей метод для обробки запиту. Після цього у рядку 3 відбувається оголошення методу, який повертає список бронювань у вигляді об'єктів BookingDto. Метод асинхронний, що дозволяє обробляти запити без блокування головного потоку. Потім йде try-catch який дозволяє виконати основний код і обробити будь-яке виключення, яке може виникнути під час операції (див. рядки 5-15). 
Власне у цьому блоку буде виконана спроба виклику асинхронного методу GetAsync сервісу _bookingService, щоб отримати список усіх бронювань (див. рядок 7). Потім йде використання AutoMapper для перетворення списку об'єктів Booking у список об'єктів BookingDto. Власне AutoMapper автоматично перенаправляє поля об'єктів Booking до відповідних полів у BookingDto (див. рядок 8). І у випадку успішного проведення операції відбувається повернення HTTP-відповіді з кодом 200 (OK) і списком BookingDto (див. рядок 9). Якщо ж у блоці try виникає виключення, управління передається у блок catch, і виключення зберігається у змінній ex (див. рядок 11). У цьому блоці відбувається логування виключення з повідомленням "Failed to get all bookings" (див. рядок 13) та повернення HTTP-відповіді з кодом 500 (Internal Server Error) і повідомленням про помилку (див. рядок 14). Таким чином працюють усі методи створених контролерів. 
У каталозі  Date знаходяться класи для взаємодії з базою даних MongoDB: MongoDbService.cs – клас, який відповідає за підключення до MongoDB та виконання основних операцій (CRUD) та TastifyDbSettings.cs – клас для зчитування налаштувань бази даних з файлу конфігурації. Розглянемо послідовно код кожного з цих класів та прокоментуємо, як він працює. Розпочнемо з коду класу MongoDbService.cs: 
1	public class MongoDbService
2	{
3	private readonly IMongoDatabase? _database;
4	public MongoDbService(IConfiguration configuration)
5	{
6	     var connectionString =                configuration.GetConnectionString("TastifyDbConnection");
7	     var mongoUrl = MongoUrl.Create(connectionString);
8	     var mongoClient = new MongoClient(mongoUrl);
9	     _database = mongoClient.GetDatabase(mongoUrl.DatabaseName);
10	}
11	public IMongoDatabase? Database => _database;
12	}
Спочатку йде оголошення класу MongoDbService, який надає можливість підключатися до MongoDB та взаємодіяти з нею (див. рядок 1). Поле _database зберігає підключення до бази даних MongoDB (див. рядок 3). Поле є приватним і може бути null (IMongoDatabase?). Далі йде конструктор класу, який приймає параметр IConfiguration для зчитування налаштувань з конфігураційного файлу (див. рядок 4). Таким чином при створенні екземпляра MongoDbService виконується ініціалізація підключення до бази даних. Далі відбувається зчитування рядка підключення до бази даних з конфігураційного файлу за ключем "TastifyDbConnection" (див. рядок 6). Використовується IConfiguration для доступу до налаштувань програми. Потім створюється об'єкт MongoUrl на основі рядка підключення (див. рядок 7). Після цього йде створення клієнта MongoDB на основі mongoUrl (див. рядок 8). 
MongoClient використовується для встановлення з'єднання з сервером MongoDB. Потім відбувається отримання конкретної бази даних з MongoDB клієнта. Для цього використовується клієнт MongoDB для доступу до бази даних, ім'я якої отримується з mongoUrl (див. рядок 9). Після цього йде властивість, яка повертає підключення до бази даних (див. рядок 11) Таким чином цей код відповідає за підключення бази даних TastifyDB у системі управління базами даних MongoBD. 
Розглянемо більш детально вміст файлу TastifyDbSettings.cs. Код цього класу наведено нижче:
1	public class TastifyDbSettings
2	{
3	public string ConnectionString { get; set; } = null!;
4	public string DatabaseName { get; set; } = null!;
5	public string RestaurantsCollectionName { get; set; } = null!;
6	public string StaffCollectionName { get; set; } = null!;
7	}
Спочатку відбувається оголошення класу TastifyDbSettings, який зберігає налаштування для підключення до бази даних MongoDB (див. рядок 1). Цей клас використовується для зчитування конфігураційних параметрів з файлу конфігурації. Потім йдуть такі властивості: ConnectionString зберігає рядок підключення до бази даних (див. рядок 3), DatabaseName зберігає ім'я бази даних (див. рядок 4),  RestaurantsCollectionName зберігає ім'я колекції ресторанів у базі даних (див. рядок 5) та StaffCollectionName зберігає ім'я колекції персоналу у базі даних (див. рядок 6). 
Також було створено класи, що представляють моделі даних, які зберігаються в базі даних. Вони зберігаються у каталозі  Entities: Booking.cs, Guest.cs, Menu.cs, Order.cs, OrderItem.cs, PositionProduct.cs, Product.cs, Restaurant.cs, Schedule.cs, Staff.cs, Table.cs. Розглянемо для прикладу код класу Order.cs:
1	public class Order
2	{
3	[BsonId]
4	[BsonElement("_id"), BsonRepresentation(BsonType.ObjectId)]
5	public string? Id { get; set; }
6	[BsonElement("number"), BsonRepresentation(BsonType.Int32)]
7	public int? number { get; set; }
8	[BsonElement("table_id"), BsonRepresentation(BsonType.ObjectId)]
9	public string? TableId { get; set; }
10	[BsonElement("date_time"), BsonRepresentation(BsonType.DateTime)]
11	public DateTime OrderDateTime { get; set; }
12	[BsonElement("comment"), BsonRepresentation(BsonType.String)]
13	public string? Comment { get; set; }
14	[BsonElement("status"), BsonRepresentation(BsonType.String)]
15	public string? Status { get; set; }
16	}
Першочергово оголошується клас Order, який представляє замовлення у системі (див. рядок 1). Клас використовується для зберігання інформації про замовлення у базі даних MongoDB. Після цього йдуть атрибути та властивості цього класу, які позначають поля у базі даних. Рядки 3-5: Створено атрибут, який позначає властивість Id як ідентифікатор документа у колекції MongoDB. Цей атрибут вказує MongoDB, що ця властивість є первинним ключем для документа. Потім йдуть атрибути BsonElement і BsonRepresentation які визначають, що властивість Id зберігається у полі _id у базі даних і має тип ObjectId. BsonElement задає ім'я поля у базі даних, а BsonRepresentation визначає, що значення цієї властивості має зберігатися як ObjectId. І після цього власне йде властивість Id, яка зберігає  унікальний ідентифікатор замовлення. Значення може бути null, що означає, що ідентифікатор може бути відсутнім або ще не встановленим. 
Після цього таким саме чином йдуть наступні властивості та атрибути до них: атрибути BsonElement і BsonRepresentation визначають, що властивість number зберігається у полі number у базі даних і має тип Int32. BsonElement задає ім'я поля у базі даних, а BsonRepresentation визначає, що значення цієї властивості має зберігатися як Int32. Властивість number зберігає номер замовлення (див. рядки 6-7). Атрибути BsonElement і BsonRepresentation визначають, що властивість TableId зберігається у полі table_id у базі даних і має тип ObjectId. BsonElement задає ім'я поля у базі даних, а BsonRepresentation визначає, що значення цієї властивості має зберігатися як ObjectId. Властивість TableId зберігає ідентифікатор столика, до якого відноситься замовлення (див. рядки 8-9). Атрибути BsonElement і BsonRepresentation визначають, що властивість OrderDateTime зберігається у полі date_time у базі даних і має тип DateTime. 
BsonElement задає ім'я поля у базі даних, а BsonRepresentation визначає, що значення цієї властивості має зберігатися як DateTime. Властивість OrderDateTime зберігає дату і час створення замовлення (див. рядки 10-11). Атрибути BsonElement і BsonRepresentation визначають, що властивість Comment зберігається у полі comment у базі даних і має тип String. BsonElement задає ім'я поля у базі даних, а BsonRepresentation визначає, що значення цієї властивості має зберігатися як String. Властивість Comment зберігає коментар до замовлення (див. рядки 12-13). Атрибути BsonElement і BsonRepresentation визначають, що властивість Status зберігається у полі status у базі даних і має тип String. BsonElement задає ім'я поля у базі даних, а BsonRepresentation визначає, що значення цієї властивості має зберігатися як String. Властивість Status зберігає статус замовлення (див. рядки 14-15). Таким чином цей клас описує структуру замовлення у базі даних MongoDB. Кожна властивість класу відповідає полю у документі MongoDB. Атрибути BsonElement та BsonRepresentation використовуються для визначення імені поля у базі даних та його типу. Таким чином цей програмний код демонструє яким чином у серверній частини програмної системи «Tastify» реалізована робота з колекціями з бази даних TastifyDB.
Відповідно до потреб програмної системи було створено усі необхідні DTOs (Data Transfer Objects). Вони використовуються для передачі даних між різними частинами застосунку, зокрема між клієнтом і сервером. Таким чином вміст каталогу Database DTOs: BookingDto.cs, GuestDto.cs, MenuDto.cs, OrderDto.cs, ProductDto.cs, RestaurantDto.cs, ScheduleDto.cs, StaffDto.cs, TableDto.cs. Ці класи відповідають сутностям баз даних і використовуються для передачі інформації між шарами застосунку. Розглянемо для прикладу програмний код класу MenuDto.cs:
1	public class MenuDto
2	{
3	public string? Id { get; set; }
4	[Required(ErrorMessage = "RestaurantId is required")]
5	public string? RestaurantId { get; set; }
6	[Required(ErrorMessage = "Name is required")]
7	[StringLength(100, MinimumLength = 1, ErrorMessage = "Name must be between 1 and 100 characters")]
8	public string? Name { get; set; }
9	[Required(ErrorMessage = "Size is required")]
10	[Range(1, int.MaxValue, ErrorMessage = "Size must be greater than 0")]
11	public int Size { get; set; }
12	[Range(1, int.MaxValue, ErrorMessage = "Price must be greater than 0")]
13	public int? Price { get; set; }
14	[StringLength(200, ErrorMessage = "Info must be at most 200 characters")]
15	public string? Info { get; set; }
16	[Required(ErrorMessage = "Type is required")]
17	public string? Type { get; set; }
18	}
Клас MenuDto представляє об'єкт передачі даних для меню у системі. Він включає кілька властивостей, що відповідають за ідентифікацію та характеристики елементів меню, і містить атрибути валідації для забезпечення коректності введених даних. У рядку 1 оголошується клас MenuDto, що містить усі необхідні властивості. Властивість Id є необов'язковим ідентифікатором меню, яка може бути null. Властивість RestaurantId є обов'язковим ідентифікатором ресторану, до якого належить меню, і забезпечується повідомленням про помилку, якщо це поле не заповнене (рядки 4-5). Поле Name також є обов'язковим і має додаткові обмеження на довжину: не менше 1 і не більше 100 символів, з відповідним повідомленням про помилку (рядки 6-8). Далі, властивість Size є обов'язковою і повинна бути більшою за 0, про що свідчать відповідні атрибути валідації (рядки 9-11). Властивість Price необов'язкова, але якщо вказана, її значення повинно бути більше 0 (рядки 12-13). 
Поле Info може містити додаткову інформацію про меню, але не повинно перевищувати 200 символів, з відповідним обмеженням на довжину (рядки 14-15). Нарешті, властивість Type є обов'язковою ідентифікує тип меню. У випадку, якщо поле не заповнене, користувач побачить відповідне повідомлення про помилку (рядки 16-17). Таким чином усі ці атрибути валідації забезпечують, що дані, передані у MenuDto, відповідають вимогам бізнес-логіки та будуть правильно оброблені на серверній частині застосунку.
Додатково було створено каталог Features DTOs, де зберігаються класи для формування спеціальних відповідей сервера, моделі яких не будуть відповідати сутностям з бази даних: CouponDto.cs, DishPopularityDto.cs, GuestLoginDto.cs, GuestRegistrationDto.cs, StaffLoginDto.cs, StaffRegistrationDto.cs та StaffReportDto.cs. Розглянемо для прикладу код класу DishPopularityDto.cs:
1	public class DishPopularityDto
2	{
3	[Required(ErrorMessage = "Name is required")]
4	public string? Name { get; set; }
5	[Required(ErrorMessage = "OrdersCount is required")]
6	[Range(0, int.MaxValue, ErrorMessage = "OrdersCount must be non-negative")]
7	public int? OrdersCount { get; set; }
8	}
Клас DishPopularityDto представляє об'єкт передачі даних, який використовується для зберігання інформації про популярність страв у системі. Він включає дві властивості, що відповідають за ім'я страви та кількість замовлень, і містить атрибути валідації для забезпечення коректності введених даних. У рядку 1 оголошується клас DishPopularityDto, що містить необхідні властивості. Властивість Name є обов'язковою ідентифікацією страви, і забезпечується повідомленням про помилку, якщо це поле не заповнене (рядки 3-4). Поле OrdersCount також є обов'язковим і повинно мати значення від 0 до максимального значення типу int, з відповідним повідомленням про помилку, якщо введене значення не відповідає цим критеріям (рядки 5-7). 
Таким чином, атрибути валідації гарантують, що дані, передані у DishPopularityDto, будуть відповідати вимогам бізнес-логіки, зокрема, ім'я страви не може бути порожнім, а кількість замовлень повинна бути не менше нуля. Це забезпечує коректну обробку даних на серверній частині застосунку, гарантуючи їх валідність перед використанням.
Для зв’язку даних між моделями та DTO було створено класи для конфігурації AutoMapper. Таким чином вміст каталогу Mapping виглядає наступним чином: AutoMapperExtensions.cs, BookingProfile.cs, GuestProfile.cs, MenuProfile.cs, OrderProfile.cs, ProductProfile.cs, RestaurantProfile.cs, ScheduleProfile.cs, StaffProfile.cs, TableProfile.cs. Розглянемо для прикладу код класу GuestProfile.cs:
1	public class GuestProfile : Profile
2	{
3	public GuestProfile()
4	{
5	     CreateMap<Guest, GuestDto>();
6	     CreateMap<GuestDto, Guest>();
7	     CreateMap<Guest, GuestRegistrationDto>();
8	     CreateMap<GuestRegistrationDto, Guest>();
9	}
10	}
Клас GuestProfile є конфігураційним класом для AutoMapper, що використовується для налаштування передачі (відображення) між різними типами об'єктів у системі. AutoMapper автоматично перенаправляє значення полів з одного типу об'єкта до відповідних полів іншого типу об'єкта, що полегшує трансформацію даних між різними шарами додатка. У рядку 1 оголошується клас GuestProfile, який успадковується від базового класу Profile AutoMapper. В конструкторі цього класу (рядки 3-9) визначаються правила перенаправлення між типами. В рядку 5 визначається перенаправлення з типу Guest до GuestDto. Це означає, що AutoMapper автоматично скопіює значення відповідних полів з об'єкта Guest в об'єкт GuestDto. В рядку 6 встановлюється зворотне перенаправлення з GuestDto до Guest, що дозволяє виконувати перетворення в обидва напрямки між цими типами. Рядки 7 і 8 визначають перенаправлення між типами Guest та GuestRegistrationDto, і навпаки. Це забезпечує можливість перетворення об'єктів Guest в GuestRegistrationDto і назад. 
Таким чином, клас GuestProfile налаштовує AutoMapper для автоматичного перенаправлення між об'єктами Guest, GuestDto та GuestRegistrationDto, що спрощує процес трансформації даних при передачі їх між різними частинами системи, наприклад, такими як шар даних і шар представлення (view).
У каталозі IServices зберігаються інтерфейси сервісів, що визначають методи для бізнес-логіки, а саме сервіси: IBookingService.cs, IGuestService.cs, IMenuService.cs, IOrderService.cs, IProductService.cs, IRestaurantService.cs, IScheduleService.cs, IStaffService.cs та ITableService.cs. Оберемо для прикладу один з цих інтерфейсів сервісів та розглянемо, як він працює. Наприклад, програмних код інтерфейсу IStaffService.cs:
1	public interface IStaffService
2	{
3	Task<List<Staff>> GetAsync();
4	Task<Staff> GetByIdAsync(string id);
5	Task CreateAsync(Staff staff);
6	Task UpdateAsync(string id, Staff updatedStaff);
7	Task RemoveAsync(string id);
8	Task<bool> AnyAsync(Func<Staff, bool> filter);
9	Task<Staff> GetByLoginAsync(string login);
10	}
Цей код визначає інтерфейс IStaffService, який описує контракт для сервісу, що керує операціями з об'єктами Staff. Інтерфейс містить методи, які реалізують основні CRUD (Create, Read, Update, Delete) операції, а також деякі додаткові функції для роботи з даними співробітників. У рядку 1 оголошується інтерфейс IStaffService. У рядку 3 метод GetAsync оголошується для асинхронного отримання списку всіх об'єктів Staff. Він повертає завдання (Task), яке містить список List<Staff>. 
У рядку 4 метод GetByIdAsync визначає асинхронний запит на отримання об'єкта Staff за його унікальним ідентифікатором (id). Він повертає завдання, що містить об'єкт Staff. У рядку 5 метод CreateAsync визначає асинхронний метод для створення нового об'єкта Staff. Він приймає об'єкт Staff як параметр і повертає завдання. У рядку 6 метод UpdateAsync оголошується для асинхронного оновлення існуючого об'єкта Staff за його ідентифікатором (id). Він приймає два параметри: id об'єкта, який потрібно оновити, та updatedStaff — оновлений об'єкт Staff. У рядку 7 метод RemoveAsync визначає асинхронний запит для видалення об'єкта Staff за його ідентифікатором (id). Він повертає завдання. 
У рядку 8 метод AnyAsync оголошується для асинхронної перевірки, чи існує будь-який об'єкт Staff, що задовольняє заданому умовному фільтру (filter). Метод приймає функцію filter як параметр і повертає завдання, що містить булеве значення (true, якщо такий об'єкт існує, і false, якщо не існує). У рядку 9 метод GetByLoginAsync визначає асинхронний запит для отримання об'єкта Staff за його логіном (login). Він повертає завдання, що містить об'єкт Staff. Таким чином, інтерфейс IStaffService визначає набір методів для роботи з об'єктами Staff, забезпечуючи стандартизований підхід до керування співробітниками в застосунку.
У каталозі Services знаходяться реалізації тих сервісів, що містять бізнес-логіку додатка та взаємодіють з MongoDB через MongoDbService: JwtTokenService (сервіс для генерації JWT токенів), BookingService.cs, GuestService.cs, MenuService.cs, OrderService.cs, PositionProductService.cs, ProductService.cs, RestaurantService.cs, ScheduleService.cs, StaffService.cs, TableService.cs. Розглянемо детально код файлу StaffService.cs (див. розділ Б.1 у додатку Б). Цей код визначає клас StaffService, який надає методи для роботи з колекціями Staff і Schedule у базі даних MongoDB. Він також використовує логер для запису інформації та помилок.
Клас StaffService починається з оголошення приватних полів _staffCollection, _scheduleCollection і _logger (див. рядки 3-5 розділ Б.1 у додатку Б). Поле _staffCollection представляє колекцію Staff у MongoDB, а _scheduleCollection — колекцію Schedule. Поле _logger використовується для логування. Конструктор класу приймає три параметри: IMongoDatabase database, IMongoCollection<Schedule> scheduleCollection та ILogger<StaffService> logger (див. рядок 7 розділ Б.1 у додатку Б). Конструктор ініціалізує _staffCollection з колекції Staff в базі даних та _scheduleCollection з переданої колекції Schedule (див. рядки 9-10 розділ Б.1 у додатку Б). Логер також ініціалізується переданим значенням (див. рядок 11 розділ Б.1 у додатку Б).
Метод GetAsync асинхронно отримує всі документи з колекції Staff та повертає їх у вигляді списку (див. рядок 15 розділ Б.1 у додатку Б). Метод GetByIdAsync асинхронно отримує документ з колекції Staff за заданим ідентифікатором id (див. рядок 18 розділ Б.1 у додатку Б). Метод CreateAsync асинхронно додає новий документ до колекції Staff (див. рядок 21 розділ Б.1 у додатку Б). Метод UpdateAsync асинхронно замінює існуючий документ в колекції Staff новим документом, визначеним параметром updatedStaff, за заданим ідентифікатором id (див. рядок 24 розділ Б.1 у додатку Б). Метод RemoveAsync асинхронно видаляє документ з колекції Staff за заданим ідентифікатором (id) (див. рядок 27 розділ Б.1 у додатку Б). Метод AnyAsync асинхронно перевіряє, чи існує будь-який документ у колекції Staff, який відповідає заданому фільтру (див. рядок 30 розділ Б.1 у додатку Б).
Метод GetByLoginAsync асинхронно отримує документ з колекції Staff за заданим логіном працівника закладу (див. рядок 33 розділ Б.1 у додатку Б). Метод GetWeeklyWorkingHoursAsync асинхронно обчислює загальну кількість відпрацьованих годин за тиждень для кожного співробітника. Він приймає дату початку (startDate) і обчислює кінцеву дату як сім днів від початкової дати (див. рядок 37 розділ Б.1 у додатку Б). Потім метод отримує всі записи з колекції Staff і для кожного співробітника обчислює кількість відпрацьованих годин на основі записів у колекції Schedule за цей період (див. рядки 41-54 розділ Б.1 у додатку Б). Загальна кількість відпрацьованих годин логуються та додаються до списку результатів, який повертається методом (див. рядки 64-66 розділ Б.1 у додатку Б). Таким чином Цей клас забезпечує повний набір CRUD операцій для колекції Staff та додаткові методи для роботи з розкладами працівників закладу, що робить його важливим компонентом для управління персоналом у додатку.
У каталозі Helpers зберігаються допоміжні класи та статичні константи. Наразі це лише клас Roles.cs, який містить визначення ролей користувачів. Надалі при масштабуванні системи інші допоміжні класи також будуть зберігатися у цьому ж каталозі. 
Тому розглянемо детально вміст файлу Roles.cs. Код цього класу наведено нижче:
1	static public class Roles
2	{
3	public const string Administrator = "admin";
4	public const string Guest = "guest";
5	public const string Worker = "worker";
6	}
Цей код визначає статичний клас Roles, який містить константи для різних ролей користувачів у системі. Використання такого класу допомагає централізувати визначення ролей і забезпечує зручний доступ до них у всьому додатку. У рядку 1 оголошується статичний клас Roles. Статичний клас не можна створити як об'єкт, він служить тільки для зберігання статичних членів, до яких можна звертатися без створення екземпляра класу. У рядку 3 визначається константа Administrator, яка має значення "admin". Ця константа використовується для позначення ролі адміністратора в системі. У рядку 4 оголошується константа Guest зі значенням "guest", що використовується для позначення ролі гостя. У рядку 5 визначається константа Worker, яка має значення "worker". Ця константа використовується для позначення ролі працівника. 
Таким чином, клас Roles забезпечує централізоване іменування ролей користувачів, що спрощує управління ролями і підвищує читабельність коду, зменшуючи ймовірність помилок, пов'язаних з неправильним введенням рядків, які представляють ролі.
Каталог Configuration містить файли конфігурації, які зберігають налаштування застосунку. Головний клас Program налаштовує і запускає сервер. 
Архітектура серверної частини проєкту на .NET 8 ASP.NET Core побудована за принципами багатошарової архітектури з чітким розділенням обов'язків між контролерами, сервісами, моделями, DTO та допоміжними класами. Використання MongoDB як бази даних забезпечує гнучкість у роботі з даними та високу продуктивність. Це дозволяє легко підтримувати, розширювати та масштабувати додаток відповідно до вимог бізнесу.


4.3	Специфікація REST API


У таблиці 4.1 детально описані всі кінцеві точки API, пов'язані з усіма функціональними можливостями програмної системи «Тastify». Структура URL-адрес використовує відповідні HTTP-запити, контролери та ідентифікатори (наприклад, /api/Booking/{bookingId}). Усі ресурси підтримують операції CRUD (Створення, Читання, Оновлення та Видалення) за допомогою відповідних методів HTTP. Деякі кінцеві точки пропонують функціональні можливості для сортування та фільтрації даних (наприклад, /api/Guest/sorted-by-name-and-bonus).  Таким чином ми отримали чітко структуровану специфікацію створеного API. Описані ресурси та їхні дії відповідають очікуванням від програмної системи автоматизації управління закладами громадського харчування «Tastify».  
Специфікація REST API наведена в таблиці 4.1 нижче.
Таблиця 4.1 – Специфікація REST API серверної частини системи
Сутність	Метод	Посилання	Дія
Backup	POST	/api/Backup/export-data	Creates a backup of the database
	GET	/api/Backup/list	Gets the list of available backups
	POST	/api/Backup/import-data	Restores a database from a backup
Booking	GET	/api/Booking	Get a list of bookings
	GET	/api/Booking/{bookingId}	Get a booking by its ID
	GET	/api/Booking/guest-bookings/{guestId}	Get all bookings of the guest by 
his ID
	GET	/api/Booking/bookins-by-date	Get all bookings by specified date.
	GET	/api/Booking/sorted-bookings-by-date	Get all bookings by specified date sorted in descending order by time
	POST	/api/Booking	Create new booking
	PUT	/api/Booking/{bookingId}	Update info about exiting booking
	DELETE	/api/Booking/{bookingId}	Delete exiting booking
Guest	GET	/api/Guest	Get all guests
	GET	/api/Guest/{guestId}	Get guest by ID
	GET	/api/Guest/sorted-by-name-and-bonus	Get all guests sorted by bonus and name
	POST	/api/Guest/register	Register a new guest
	POST	/api/Guest/login	Login as a guest
	POST	/api/Guest/make-coupon	Make a coupon for a guest based 
on bonus points
	PUT	/api/Guest/{guestId}	Update a guest's information
	DELETE	/api/Guest/{guestId}	Delete a guest



Продовження таблиці 4.1
Menu	GET	/api/Menu	Get all dishes
	GET	/api/Menu/{menuId}	Get dish by ID
	GET	/api/Menu/restaurant/
{restaurantId}/menu	Get the menu for a specific restaurant by its ID
	GET	/api/Menu/restaurant/
{restaurantId} /first-dishes	Get the first dishes for a specific restaurant
	GET	/api/Menu/restaurant/
{restaurantId} /second-dishes	Get the second dishes for a specific restaurant
	GET	/api/Menu/restaurant/
{restaurantId} /drinks	Get the drinks for a specific restaurant
	GET	/api/Menu/restaurant/
{restaurantId} /dishes-rating	Get a list of dishes and statistics 
on their orders in a restaurant
	POST	/api/Menu	Create a new dish
	PUT	/api/Menu/{menuId}	Update a dish by ID
	DELETE	/api/Menu/{menuId}	Delete a dish by ID
Order	GET	/api/Order	Get all orders
	GET	/api/Order/{orderId}	Get an order by ID
	POST	/api/Order	Create a new order
	PUT	/api/Order/{orderId}	Update an existing order
	DELETE	/api/Order/{orderId}	Delete an order
Product	GET	/api/Product	Get all products
	GET	/api/Product/{productId}	Get a product by ID
	POST	/api/Product	Create a new product
	PUT	/api/Product/{productId}	Update an existing product
	DELETE	/api/Product/{productId}	Delete a product



Продовження таблиці 4.1
Restaurants	GET	/api/Restaurants	Get all restaurants
	GET	/api/Restaurants/
{restaurantId}	Get a restaurant by ID
	POST	/api/Restaurants	Create a new restaurant
	PUT	/api/Restaurants/
{restaurantId}	Update an existing restaurant
	DELETE	/api/Restaurants/
{restaurantId}	Delete a restaurant
Schedule	GET	/api/Schedule	Get all schedules
	GET	/api/Schedule/{scheduleId}	Get a schedule by ID
	GET	/api/Schedule/staff/{staffId}	Get schedule by staff ID
	POST	/api/Schedule	Create a new schedule
	PUT	/api/Schedule/{scheduleId}	Update an existing schedule
	DELETE	/api/Schedule/{scheduleId}	Delete a schedule by ID
Staff	GET	/api/Staff	Get all staff members
	GET	/api/Staff/{staffId}	Get a staff member by ID
	GET	/api/Staff/weekly-working-
hours	Get weekly working hours of staff members
	POST	/api/Staff/register	Register a new staff member
	POST	/api/Staff/login	Log in a staff member
	PUT	/api/Staff/{staffId}	Update staff member by ID
	DELETE	/api/Staff/{staffId}	Delete a staff member by ID
Table	GET	/api/Table	Get all tables
	GET	/api/Table/{tableId}	Get a table by ID
	POST	/api/Table	Create a new table
	PUT	/api/Table/{tableId}	Update a table by ID
	DELETE	/api/Table/{tableId}	Delete a table by ID


4.4	Тестування


Тестування створеної серверної частини застосунку було використано Swagger через низку його переваг. Він надає легкий доступ до API документації (Swagger генерує документацію API на основі коду, що допомагає розробникам швидко зрозуміти, як працює API без необхідності читати весь код), забезпечує просте тестування кінцевих точок (за допомогою Swagger можна легко виконувати тестування кінцевих точок без необхідності використання сторонніх інструментів), а  Swagger UI надає зручний інтерфейс для взаємодії з API і більше того Swagger дозволяє взаємодіяти з API у реальному часі, вводити дані та переглядати результати без необхідності встановлення додаткових інструментів. Також Swagger дозволяє швидко перевіряти валідацію даних, введених у форми або переданих в запитах, що допомагає виявити можливі помилки у валідації ще до того, як вони потраплять на сервер. 
Swagger може бути використаний для тестування різних аспектів безпеки, таких як аутентифікація та авторизація, які були реалізовані за допомогою використання JWT-токенів.
Під час тестування була перевірена робота усіх методів та відповідності запитів до певного HTTP методу (GET, POST, PUT, DELETE). Було проведене тестування на отримання запитів неавторизованими користувачами та авторизованими за різними ролями. І також була перевірена валідація усіх даних, що приймає сервер для обробки чи подальшого запису у базу даних. Таким чином під час тестування було встановлено, що сервер забезпечує правильні відповіді на всі можливі запити користувача та правильно обробляє помилки, які можуть виникнути під час виконання запитів. 


5	РОЗРОБКА КЛІЄНТСЬКОЇ ЧАСТИНИ
5.1	Структура та технології клієнтської частини програмної системи


Для більш детальної візуалізації архітектури системи було розроблено UML діаграму компонент (див. рис. А.4 у додатку А). Каталог public містить файли, які повинні бути доступні публічно, тобто ті, які сервер буде обслуговувати безпосередньо. Це включає: index.html (головна HTML-сторінка, яка є точкою входу у вебзастосунок, яка завантажує основний JavaScript код та стилі), стильові файли, які застосовуються до HTML, шрифти, використовувані у проекті, зображення, використовувані на сторінках та файли локалізації для підтримки англійської та української мов (en.json, ua.json). Каталог Private містить усі вихідні файли проекту, які не будуть безпосередньо доступні публічно. Це компоненти JavaScript коду, стилі, специфічні для компонентів, і інші ресурси, що використовуються під час побудови додатку. Файл LoginPage.html не розміщений у жодному з підкаталогів (admin чи staff), оскільки він обслуговує спільну функціональність, яка не прив'язана до жодної конкретної ролі. Це точка входу для автентифікації користувачів, незалежно від того, чи є вони адміністраторами чи працівниками. Це спрощує підтримку і зменшує дублювання коду, так як одна й та ж сторінка входу може бути використана для всіх типів користувачів. Розділення на staff і admin в обох каталогах (components і pages) дозволяє чітко розмежувати функціональність і компоненти, які належать до різних ролей користувачів: Admin (адміністратор) – ці компоненти та сторінки призначені для адміністративних функцій, таких як управління даними, меню, замовленнями, продуктами, рестораном, розкладом та персоналом та Staff (персонал) – ці компоненти та сторінки призначені для повсякденних завдань персоналу, таких як управління замовленнями, перегляд розкладу, профіль користувача. Таке розділення забезпечує чіткість та організованість коду, розмежування доступу (полегшує впровадження правил доступу та авторизації, оскільки чітко визначено, які частини додатку належать до якої ролі), модульність і масштабованість оскільки дозволяє легше додавати нові функції для конкретної ролі без ризику порушення функціональності іншої ролі. App.js є основним файлом додатку, який імпортує та використовує інші компоненти. Він відповідає за маршрутизацію між HTML-сторінками. Ця структура організована таким чином, щоб розділити функціональність адміністратора та персоналу, забезпечуючи чіткий поділ обов'язків і зручність у навігації та підтримці коду. Вона полегшує підтримку, масштабування та розвиток проекту, забезпечуючи чітке розмежування функціональних областей і ролей користувачів.
У розробці клієнтської частини були використані  HTML, CSS, JavaScript. Взаємодія з сервером частково була реалізована за допомогою  Fetch API (шляхом виконання асинхронних запитів до серверу та отримання/відображення даних на сторінці).  Був використано DOM API для роботи з HTML-документами напряму. Логіка розділена на функції, наприклад, для виклику серверних операцій, отримання та відображення даних. Загалом система орієнтована на RESTful API, власне за допомогою якого і була розроблена серверна частина системи на попередній роботі. 


5.2	Архітектура клієнтської частини програмної системи


Архітектуру проекту можна описати як модульну та багатошарову архітектуру. Використання модульної архітектури організовує код у незалежні та взаємозамінні модулі. Кожен модуль має чітко визначену роль і може бути розроблений, протестований, змінений та повторно використаний окремо від інших модулів. 
Багатошарова архітектура організовує систему на кілька шарів або рівнів, кожен з яких виконує певну роль. JavaScript код, що працює у браузері, відповідає за взаємодію з користувачем (відображення замовлень, заповнення випадних списків, обробку подій натискання кнопок та інше), тому це презентаційний шар. Шар логіки реалізовує серверний API, який обробляє HTTP-запити, відповідає за обробку запитів до бази даних, виконання бізнес-логіки, та повернення відповідей клієнту. Шар доступу до даних також знаходиться у серверній частині застосунку і відповідає за збереження та отримання даних з бази даних. Але при цьому він відокремлений від сервісів з бізнес-логікою застосунку та контролерів, які відповідають лише за отримання HTTP-запитів та відправці HTTP-відповідей [3].
Комунікація між сервером та клієнтською частиною здійснюється за допомогою використання REST API, бо він забезпечує простоту, гнучкість та стандартизацію взаємодії між клієнтами та серверами за допомогою стандартних HTTP-методів, сприяючи легкій інтеграції та ефективній обміну даними у розподілених системах та підтримує роботу з форматом даних JSON. 
HTML файли відповідають за структуру і вміст вебсторінок. CSS файли відповідають за стильове оформлення вебзастосунку. JavaScript файли відповідають за логіку на стороні клієнта, розташовані в директорії src/components для модульних компонентів та інших скриптів клієнтської логіки. Файли Локалізації (en.json і ua.json) забезпечують підтримку інтернаціоналізації, дозволяючи додатку підтримувати англійську та українську мови. Архітектура проекту добре структурована і модульна, з чітким розподілом відповідальностей. Ця архітектура відповідає типовій структурі додатку на основі React, використовуючи компоненти для управління функціональністю і публічну директорію для статичних ресурсів і локалізації. 
Розглянемо на прикладі JavaScript код вебсторінки для адміністрування столів у закладі громадського харчування адміністратором (див. код функції у розділі Б.2 додатку Б). Цей код є JavaScript скриптом для вебсторінки, який керує таблицею "Tables" за допомогою API. Після завантаження сторінки та DOM (DOMContentLoaded), виконується fetchTables для отримання даних про таблиці з API та їх відображення. Функція getToken отримує токен з localStorage для авторизації запитів. Функція fetchTables робить запит до API, отримує список таблиць та передає його до displayTables для відображення. Функція displayTables створює HTML-рядки для кожної таблиці та додає їх до таблиці у DOM. Користувач може додавати, редагувати, зберігати, видаляти або скасовувати зміни таблиць. Ці дії обробляються відповідними функціями (handleAdd, handleEdit, handleSave, handleDelete, handleCancel), які роблять запити до API та оновлюють відображення таблиць після завершення дії. 
Такий підхід забезпечує чітку архітектуру та розділення обов'язків між різними частинами коду, що полегшує його подальшу підтримку та розширення функціональності у майбутньому.


6	РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ
6.1	Структура та технології мобільного застосунку програмної системи


У розробці мобільного застосунку була використана мова програмування Kotlin. Kotlin повністю сумісний з Java, що дозволяє використовувати існуючий код на Java та бібліотеки разом з новими функціями Kotlin. Kotlin дозволяє писати менше коду завдяки лаконічним синтаксичним конструкціям. Зменшення кількості шаблонного коду робить програму більш зрозумілою та менш схильною до помилок. Kotlin має вбудовані механізми для роботи з нульовими значеннями, що знижує ймовірність виникнення помилок NullPointerException. Kotlin підтримує функціональне програмування, що дозволяє використовувати лямбда-вирази, високорівневі функції та інші функціональні конструкції. Це сприяє більшій гнучкості та виразності коду. Використання Kotlin для розробки мобільних застосунків на Android дає змогу розробникам створювати надійні, ефективні та підтримувані програми з меншою кількістю коду та кращою інтеграцією сучасних можливостей мов програмування [4]. Середою розробки було обрано Android Studio. 
Була розроблена діаграма пакетів (див. рис. 6.1) для візуалізації використаних пакетів у проекті. Вона покращить розуміння структури проекту та взаємозв’язків між його компонентами, тож розглянемо її детально. 
Для розширення можливостей Kotlin у Android використовується пакет core-ktx, який забезпечує зручну та ефективну взаємодію з різними компонентами Android. Таким чином використання цього пакету дозволить розробникам писати більш чистий, безпечний та компактний код. Це значно прискорить розробку та спростить підтримку застосунку. 
Додатково був підключен пакет appcompat для підтримки старих версій Android і забезпечення сумісності з сучасними функціями. застосовується пакет appcompat. Таким чином додатки, які будуть виглядати цілком однаково, зможуть працювати на різних версіях Android. 
Був підключен пакет material для створення інтерфейсів користувача з компонентами Material Design для створення привабливих і сучасних інтерфейсів простішим шляхом, забезпечуючи при цьому однаковий вигляд додатків на різних платформах. Пакет ConstraintLayout  надає можливість створення адаптивних та гнучких макетів інтерфейсу з автоматичними налаштуваннями до екранів пристроїв. Це значно спрощує розробку складних інтерфейсів користувача та забезпечує швидку розробку застосунків шляхом чіткого контролю розташування елементів інтерфейсу. 
Була підключена бібліотека retrofit, яка значно спрощує роботу з мережевими HTTP-запитами, забезпечуючи високий рівень абстракції та підтримку різних форматів обміну даними.  HTTP клієнт okhttp використовується для взаємодії з вебслужбами через HTTP запити. OkHttp забезпечує швидку та надійну роботу з мережевими запитами, маючи при цьому простий та легкий у використанні інтерфейс. 
Для декодування JSON Web Token (JWT) була підключена бібліотека jwtdecode. Вона надає можливість перевіряти автентифікаційні та авторизаційні токени  шляхом декодування та розшифрування JWT. Використання JWT спрощує реалізацію механізмів аутентифікації та авторизації в додатках, забезпечуючи безпеку та конфіденційність даних. 

 
Рисунок 6.1 – UML діаграма пакетів мобільної частини програмної системи
6.2	Архітектура мобільного застосунку програмної системи


Проект було розроблено за принципами багатошарової архітектури. Вона представлена презентаційним шаром (директорії activities та adapters, які відповідають безпосередньо за відображення даних та взаємодію з користувачем), доменним шаром (директорія services, яка містить бізнес-логіку застосунку, бо сервіси взаємодіють з моделями відповідними до бази даних та відповідають за основні операції з цими даними) та шаром даних (він містить власне моделі даних у директорії models та у директорії api, де знаходяться класи для з’єднання з базою даних та виконання усіх HTTP-запитів до серверної частини застосунку). 
Для відображення усіх компонентів системи була розроблена діаграма компонент (див. рис. А.5 у додатку А). Розглянемо детально усі основні компоненти системи, які зосереджено у директоріях activities, api, adapters, services, models та util. У директорії activities знаходяться основні екранні компоненти застосунку, кожен з яких відповідає за окремий екран і взаємодію користувача з цим екраном. Наприклад, BookingsActivity.kt відповідає за екран бронювань столів у закладі громадського харчування (див. код Б.3 у додатку Б). 
Окрему увагу було приділено життєвому циклу застосунку. Після запуску застосунку спочатку спрацьовує метод OnCreate(), який відповідає за підключення layout. Одразу після цього викликається метод OnStart(). Він ініціалізує усі необхідні об’єкти для поточного activity (наприклад, findViewById). Також прописані додаткові методи, як OnSaveInstabceState() для коректного збереження даних у полях вводу при подіях, які можуть замість застосунку відкрити інший застосунок на пристрої чи перезавантажити поточний (наприклад, телефонний дзвінок або зміна орієнтації на сматрфоні) та OnRestoreInstanceState() для відновлення даних у цих полях вводу.
Директорія api містить у собі компоненти для роботи з мережею, а саме ApiService.kt – відповідає за виконання HTTP-запитів та отримання HTTP-відповідей від серверної частини застосунку, NetworkModule.kt – відповідає за налаштування мережевого підключення, TokenManager.kt – відповідає за роботу з JWT-токенами для авторизації відвідувача закладу та отримання даних про нього, як про авторизованого користувача. 
Директорія adapters містить усі необхідні адаптери для відображення списків даних у RecyclerView. Наприклад, BookingsAdapter – буде відповідати за відображення списку усіх бронювань авторизованого гостя (див. код Б.4 у додатку Б), а MenuAdapter – за відображення списку усіх страв та напоїв з меню закладу. 
У пакеті models знаходяться усі необхідні моделі даних для відображення структури даних, що обробляються у застосунку та зберігаються у базі даних.  
У директорії services знаходяться сервіси, що відповідають за виконання бізнес-логіки застосунку: AuthService.kt – містить функції для входу у застосунок та реєстрації нового користувача, BookingsService.kt – містить функції для роботи з бронюваннями користувача (див. код Б.5  у додатку Б), ProfileService.kt – містить функції для роботи з особистими даними користувача та його бонусними балами. 
Пакет util містить допоміжні класи та утіліти, як DateTypeUtil – для форматування дати та NavigationUtil – для налаштування навігації між екранами застосунку.


7	ОПИС ПРОГРАМНОЇ СИСТЕМИ
7.1	Загальні відомості


Для роботи з базою даних було обрано систему управління базами даних MongoDB. Серверна частина застосунку була розроблена у середовищі Microsoft Visual Studio 2022 з використанням фреймворку ASP.NET Core мови програмування C#. Вебзастосунок було розроблено у програмному середовищі Visual Studio Code за допомогою HTML, CSS та JavaScript. Мобільний застосунок було розроблено у програмному середовищі Android Studio (Jellyfish 2023.3.1) на мові програмування Kotlin.
MongoDB - це нереляційна база даних, що робить її гнучкою та масштабованою. Це важливо, оскільки вебзастосунок може мати мінливі вимоги до даних у міру зростання. Також MongoDB відома своєю високою продуктивністю та швидкістю роботи, що важливо для забезпечення чутливого доступу користувачів до вебзастосунку. ASP.NET Core чудово підходить для створення сучасних та масштабованих вебзастосунків. Він пропонує широкий спектр функцій, таких як маршрутизація, автентифікація та авторизація. 
HTML використовується для створення структури вебсторінок. CSS використовується для стилізації вебсторінок. JavaScript використовується для створення інтерактивних вебсторінок та роботи з HTTP-запитами до серверної частини. Android Studio – офіційне середовище розробки для Android, яке пропонує широкий спектр інструментів та функцій, що полегшують розробку мобільних застосунків. Kotlin пропонує чіткий та простий синтаксис та велику спільноту розробників. Тому вибір технологій, описаних вище, ґрунтується на їх гнучкості, простоті використання, продуктивності та відповідності вимогам вебзастосунку. Ці технології дозволять розробити масштабований, зручний та швидкий вебзастосунок, який відповідатиме потребам користувачів. 
Мінімальні вимоги характеристик персонального комп’ютеру для коректної роботи створеної програмної системи автоматизації управління закладами громадського харчування «Tastify»:
	операційна система Windows 10 (64-bit), macOS 10.14 (Mojave), Linux (Ubuntu 18.04) для вебсайту, операційна система Android 5.0 (Lollipop) для мобільного застосунку;
	процесор Intel Core i5-4460 (2.8 GHz) або AMD Ryzen 3 1200 (3.1 GHz);
	пам'ять 8 GB RAM;
	вільне місце на мобільному пристрої 70 MB;
	вільного місця на комп’ютері 2 GB;
	браузер Google Chrome, Mozilla Firefox, Microsoft Edge.
Для роботи застосунків потрібне активне підключення до Інтернету. Для запуску серверної частини може знадобитися додаткове програмне забезпечення, таке як Visual Studio, ASP.NET Core SDK та MongoDB. Для кращої продуктивності рекомендується використовувати більш потужний пристрій, ніж зазначено в мінімальних вимогах. Якщо будуть присутні проблеми з продуктивністю, треба спробувати очистити кеш та кукі-файли браузера. 


7.2	Виклик і завантаження


Для початку роботи з вебзастосунком необхідно завантажити архів з програмною системою та розархівувати його. Оскільки серверна частина розроблена у VisualStudio 2022 з використанням MongoDB, необхідно завантажити їх з офіційних сайтів розробника. 
Після цього необхідно відкрити файл TastifyAPI/appsettings.json і змінити рядок з’єднання з базою даних на актуальний, що встановлюється при запуску MongoDB (див. рис. 7.2.1).
 
Рисунок 7.2.1

Потім необхідно запустити серверну частину застосунку, натиснувши на зелений трикутник у Visual Studio (див. Рис. 7.2.2).

 
Рисунок 7.2.2

Для початку роботи з мобільним застосунком необхідно відкрити файл Tastify.apk у архіві програмної системи та встановити програму на мобільний пристрій.  


7.3	Призначення і логічна структура


Розглянемо логічну структуру створеної програмної системи у декількох модулях:
	авторизація та реєстрація;
	користувачі системи;
	ресторани;
	продукти;
	замовлення;
	бронювання;
	столи;
	дані системи.
Модуль «Авторизація та реєстрація» містить у собі функціонал для входу у систему за логіном і паролем для зареєстрованих користувачів та створення нового облікового запису для нових користувачів.
Модуль «Користувачі системи» містить у собі функціонал для управління усіма користувачами системи, а саме гостями та працівниками закладів громадського харчування. Гості можуть змінювати особисту інформацію про себе, а працівники записувати свої робочі зміни. Доступ до управління іншими даними користувачів є лише у адміністратора. Наприклад, видалення чи додавання нових працівників до системи.
Модуль «Ресторани» містить у собі функціонал для перегляду та управління інформацією про заклади громадського харчування. 
Модуль «Продукти» містить у собі функціонал для управління обліком харчових продуктів, що є у наявності у закладі громадського харчування і будуть використані для приготування страв та напоїв (перегляд списку, додавання нових, редагування та  видалення існуючих).
Модуль «Замовлення» містить у собі функціонал для управління замовленнями відвідувачів (перегляд інформації про замовлення, додання нових замовлень, редагування та видалення існуючих).
Модуль «Бронювання» містить у собі функціонал для управління бронюваннями відвідувача (перегляд інформації про бронювання відвідувача та усіх бронювань у закладі, додавання нових бронювань, зміна інформації чи відміна запланованих). Доступ до нього маюсь як відвідувачі закладів громадського харчування, так і адміністратори.
Модуль «Столи» містить у собі функціонал для управління столами у закладах громадського харчування (перегляд списку та статусів, додавання нових, редагування чи видалення існуючих). Доступ до цього модулю є у усіх працівників закладів та адміністраторів.
Модуль «Дані системи» містить у собі функціонал для управління резервними копіями бази даних програмної системи. Доступ до цього модулю є лише у адміністратора системи. У функціонал цього модулю входить перегляд резервних копій за датами створення, створення резервної копії чи відновлення бази даних за вже існуючою резервною копією.


7.4	Опис програмної реалізації вебзастосунку


Для початку роботи з вебзастосунком користувачу спочатку необхідно авторизуватися. Для цього користувачу необхідно ввести свій логін та пароль. Після цього система визначить за яку роль увійшов працівник (адміністратор чи звичайний працівник) та перенаправить його на відповідну сторінку, на якій буде доступний увесь функціонал саме для його ролі. Сторінка авторизація зображена на рисунку 7.4.1.


 
Рисунок 7.4.1 – Вікно входу до особистого акаунту користувача

При неправильному вводі логіну чи паролю користувач отримає повідомлення від браузера про некоректне введення інформації (див. рис. 7.4.2).

 
Рисунок 7.4.2 – Результат неправильного вводу логіну та паролю при авторизації

У іншому випадку, якщо користувач правильно введе свої логін та пароль, він потрапить на відповідну сторінку з функціоналом саме для його ролі. Наприклад, при авторизації за даними адміністратора ми отримаємо доступ до повного функціоналу системи. Спочатку він опиниться на сторінці роботи з меню закладу (див. рис. 7.4.3).
 
Рисунок 7.4.3 – Вікно роботи з меню закладу

Для того щоб додати нову страву користувачу необхідно прогортати сторінку до кінця списку наявних страв та напоїв. Там необхідно заповнити усі поля з інформацією про нову страву чи напій та у випадному списку обрати тип страви. Після цього натиснути на кнопку «Add New» («Додати» для української локалізації). Приклад додавання нової страви наведено на рисунку 7.4.4.

 
Рисунок 7.4.4 – Приклад додавання нової страви до меню

При додаванні нової страви буде виведено повідомлення про успішне додавання нової позиції до меню (див. рис. 7.4.5). 
І після цього таблиця з меню оновиться і у списку з’явиться нова страва чи напій.
 
Рисунок 7.4.5. – Повідомлення про успішне додавання нової позиції до меню

Біля кожної позиції меню є кнопки «Edit» та «Delete» («Редагувати» та «Видалити» для української локалізації відповідно). Вони відповідають за редагування інформації про позицію та її видалення. При натисканні на «Edit» з’являються поля вводу, куди автоматично записано попередню інформацію про позицію з меню. Для зміни необхідно змінити бажані поля та натиснути на «Save» («Зберегти» для української локалізації). Для відміни змін необхідно натиснути «Cancel» («Відмінити» для української локалізації). Приклад зміни інформації про позицію з меню наведено на малюнку 7.4.6.

 
Рисунок 7.4.6 – Зміна інформації про позицію з меню

При натисканні на «Cancel» зміни не будуть збережені і інформація про страву чи напій буде збережена у попередньому вигляді. При натисканні на «Delete» страва буде вилучена з меню та таблиця оновиться.
Також на сторінці зверху присутні кнопки для фільтрації виводу позицій з меню. До цього моменту було обрано «Full Ment» («Повне меню» для української локалізації). При натисканні на «First dishes» («Перші страви» для української локалізації) та натисканні на кнопку «Go» («Дивитися» для української локалізації) у таблицю буде виведено лише перші страви з меню (див. рис. 7.5.6). 

 
Рисунок 7.4.6 – Результат фільтрації для перших страв з меню

При натисканні на «Second dishes» («Другі страви» для української локалізації) та натисканні на кнопку «Go» у таблицю буде виведено лише другі страви з меню (див. рис. 7.5.7).

 
Рисунок 7.4.7 – Результат фільтрації для других страв з меню

При натисканні на «Drinks» («Напої» для української локалізації) та натисканні на кнопку «Go» у таблицю буде виведено лише напої з меню (див. рис. 7.5.8).

 
Рисунок 7.4.8 – Результат фільтрації для напоїв з меню

При натисканні на останню з можливих кнопок «All by popularity» («За популярністю» для української локалізації) та натисканні на кнопку «Go» у таблицю буде виведено назви позицій з меню у порядку від найпопулярнішої за кількістю замовлень і до позиції, яку замовляють найрідше (див. рис. 7.5.9).

 
Рисунок 7.4.9 – Результат сортування за популярністю замовлень позицій із меню

При натисканні на «Orders» у боковому меню сторінки («Замовлення» для української локалізації), користувач переходить до вікна роботи з замовленнями у ресторані (див. рис. 7.4.10).

 
Рисунок 7.4.10 – Сторінка роботи з замовленнями

Для додавання нового замовлення потрібно внизу таблиці замовлень заповнити форму інформацією про нове замовлення. Для цього необхідно ввести номер замовлення, обрати з випадного списку номер столу, дату та час замовлення, додатковий коментар кухарям або офіціантам (за бажанням) та статус замовлення. 
Дата та час замовлення обирається завдяки спеціальному вікну (див. рис. 7.4.11), у якому автоматично визначається поточний час та день. Статус замовлення обирається у випадному списку серед запропонованих статусів (див. рис. 7.4.12). 
І останнім кроком для додавання замовлення користувач повинен натиснути на кнопку «Add New».
 
Рисунок 7.4.11 – Обрання дати та часу нового замовлення

 
Рисунок 7.4.12 – Обрання статусу нового замовлення

При успішному заповненню форми та натисканню на кнопку, буде виведено повідомлення про успішне додавання нового замовлення (див. рис. 7.4.13) та оновлена таблиця замовлень.

 
Рисунок 7.4.13 – Повідомлення про успішне додання нового замовлення
Біля кожного замовлення є кнопки «Edit» та «Delete» для зміни інформації про замовлення та його видалення. При натисканні на кнопку «Edit» у таблиці з’являється форма для зміни інформації про замовлення та кнопки «Save» та «Cancel» для збереження чи відміни змін (див. рис. 7.4.14).

 
Рисунок 7.4.14 – Зміна інформації про замовлення

При натисканні на кнопку «Delete» замовлення буде видалено з таблиці. Після цього видалене замовлення буде відсутнє у оновленій таблиці та у базі даних програмної системи.
При натисканні на «Bookings» у боковому меню сторінки, користувач переходить на сторінку управління бронюваннями гостей (див. рис. 7.4.15). Тут відображено список усіх бронювань у ресторані з інформацією про гостя, дату та час бронювання, кількість гостей та коментар.

 
Рисунок 7.4.15 – Сторінка роботи з бронюваннями гостей

Для того, щоб додати нове бронювання необхідно внизу таблиці заповнити форму. Там треба обрати гостя з випадного списку (див. рис. 7.4.16), дату та час бронювання, кількість людей та за бажанням додатковий коментар і натиснути на кнопку «Add New». 

 
Рисунок 7.4.16 – Додавання нового бронювання для гостя зі списку
Для зміни інформації про певне бронювання необхідно натиснути на кнопку «Edit», змінити усю бажану інформацію та натиснути на кнопку «Save» (див. рис. 7.4.14).

 
Рисунок 7.4.17 – Редагування інформації про бронювання

При натисканні у боковому меню на «Tables» користувач перейде на сторінку роботи зі столами у закладі (див. рис. 7.4.18).

 
Рисунок 7.4.18 – Сторінка роботи зі столами у закладі
Для додавання нового столу потрібно внизу списку наявних столів заповнити форму з номером столу та його статусом з випадкого списку (див. рис. 7.4.19). Після цього слід натиснути на кнопку «Add New».

 
Рисунок 7.4.19 – Додавання нового столу

При правильному заповненні форми після натискання кнопки «Add New» буде виведено системне повідомлення про те, що новий стіл було успішно додано (див. рис. 7.4.20).

 
Рисунок 7.4.20 – Повідомлення про успішне додавання нового столу

Також біля кожного столу присутні кнопки «Edit» та «Delete» для редагування інформації про стіл та його видалення відповідно. Для редагування інформації про стіл слід натиснути на кнопку «Edit», заповнити форму та натиснути кнопку «Save» (див. рис. 7.4.21). При натисканні на кнопку «Cancel» зміни будуть відхилені.

 
Рисунок 7.4.21 – Редагування інформації про стіл

При видалення столу (натисканні на кнопку «») буде виведено системне повідомлення про те, що стіл було успішно видалено (див. рис. 7.4.22).

 
Рисунок 7.4.22 – Повідомлення про успішне видалення столу

При натисканні на «Staff» у боковому меню сторінки, користувач перейде на сторінку управління персоналом (див. рис. 7.4.23). Окрім аналогічних до інших сторінок кнопок «Add New», «Edit» та «Delete», наявна кнопка «Get workers report» («Отримати звіт за працівниками» для української локалізації) та вікно для вводу дати. Ця кнопка відповідає за отримання кількості відпрацьованих годин кожним співробітником за певний тиждень.
 
Рисунок 7.4.23 – Сторінка управління працівниками

Для додавання нового працівника необхідно внизу списку усіх працівників заповнити форму інформацією про нового працівника. Посаду працівника треба обрати з варіантів, які буде наведено у випадному меню у формі створення нового працівника (див. рис. 7.4.24). 

 
Рисунок 7.4.24 – Вибір посади при додаванні нового працівника

Назву закладу громадського харчування теж слід обрати з випадного списку у формі (див. рис. 7.5.25).
 
Рисунок 7.4.25 – Вибір закладу при додаванні нового працівника

Після цього треба натиснути кнопку «Add New». З’явиться повідомлення з проханням ввести пароль для подальшої авторизації новим працівником у системі (див. рис. 7.4.26).

 
Рисунок 7.4.26 – Вікно задання паролю для нового працівника

При коректному вводі паролю та підтвердженні буде виведено повідомлення про успішне додання нового працівника до системи (див. рис .7.4.27).

 
Рисунок 7.4.27 – Повідомлення про успішне додавання нового працівника
Для зміни інформації про працівника необхідно натиснути біля нього на кнопку «Edit», змінити бажану інформацію та підтвердити усі внесені зміни (див. рис. 7.4.28).

 
Рисунок 7.4.28 – Зміна інформації про працівника

При видаленні працівника буде виведено повідомлення, де користувач повинен або підтвердити або відмінити видалення працівника (див. рис. 7.4.29).

 
Рисунок 7.4.29 – Вікно підтвердження видалення працівника

При натисканні на «Get workers report», користувач отримає звіт з роботи працівників за тиждень (починаючи з дня, дату якого він самостійно обирає у полі, яке знаходиться одразу над кнопкою «Get workers report»). Результат отримання звіту наведено на рисунку 7.4.30.

 
Рисунок 7.4.30 – Результат отримання звіту з роботи працівників за тиждень

При натисканні на «Schedule» у боковому меню сторінки, користувач потрапить на сторінку управління робочими змінами працівників (див. рис. 7.4.31).

 
Рисунок 7.4.31 – Сторінка роботи з робочими змінами працівників
Для додавання нової робочої зміни слід заповнити форму, яка знаходиться внизу під усіма наявними робочими змінами працівників. Слід обрати працівника, зміну до розкладу якого слід додати зміну з випадного списку (див. рис. 7.4.32).

 
Рисунок 7.4.32 – Додавання нової робочої зміни певному працівнику

Також слід обрати початок та кінець робочої зміни (дату та час). Для цього використовується календар (див. рис. 7.4.33).

 
Рисунок 7.4.33 – Вікно обрання дати для початку робочої зміни

Для того, щоб змінити інформацію про певну робочу зміну слід натиснути «Edit» поруч із нею і змінити усі бажані дані, після чого підтвердити зміни натиснувши на кнопку «Save» (див. рис. 7.4.34).
 
Рисунок 7.4.34 – Зміна інформації про робочу зміну

При натисканні на «Restaurant» у боковому меню сторінки, користувач потрапляє на сторінку з інформацією про заклад, до якого відноситься авторизований працівник (див. рис. 7.4.35).

 
Рисунок 7.4.34 – Сторінка з інформацією про заклад
При натисканні на «Products» у боковому меню сторінки, користувач потрапляє на сторінку управління обліком харчових продуктів, наявних у закладі (див. рис. 7.4.36).

 
Рисунок 7.4.36 – Сторінка управління обліком харчових продуктів закладу

Для того, щоб додати новий харчовий продукт слід заповнити форму внизу усіх наявних продуктів та натиснути кнопку «» (див. рис. 7.4.37).

 
Рисунок 7.4.37 – Додавання нового харчового продукту
При успішному занесенні продукту за умови правильного заповнення форми, до системи буде виведено повідомлення про успішне додавання продукту до системи (див. рис. 7.4.38).

 
Рисунок 7.4.38 – Повідомлення про успішне додавання нового продукту

Також зверху сторінки користувачу доступні різні варіанти сортування відображення харчових продуктів. При обранні опції «name (a-z)» («за назвою а-я» при українській локалізації) та натисканні на кнопку «Go», продукти будуть виведені відсортовані за алфавітним порядком (див. рис. 7.4.39).

 
Рисунок 7.4.39 – Сортування за назвами продуктів за алфавітним порядком

При обранні зворотної опції «name (z-a)», продукти будуть виведену за зворотнім до алфавіту порядком (див. рис. 7.4.40).

 
Рисунок 7.4.40 – Сортування за назвами за зворотнім алфавітним порядком

При обранні опції «amount (asc)» продукти будуть відсортовані за їх кількістю у наявності у порядку зростання (див. рис. 7.4.41).
 
Рисунок 7.4.41 – Сортування за кількістю продуктів за зростанням
При обранні опції «amount (desc)» продукти будуть відсортовані за їх кількістю у наявності у порядку спадання (див. рис. 7.4.42).

 
Рисунок 7.4.42 – Сортування продуктів за кількістю у порядку спадання

При обранні «Database» у боковому меню сторінки користувач перейде на сторінку роботи з даними системи. Тут буде наведено список наявних резервних копій бази даних системи, та кнопки для відновлення бази даних на певною резервною копією («Restore») та кнопка для створення нової резервної копії бази даних у її поточному наповненні («Make database backup»). Для української локалізації ці кнопки називаються «Відновити» та «Створити резервну копію» відповідно. Ця сторінка зображена на рисунку 7.4.43). Усі файли створених резервних копій мають назву у форматі backup_TastifyDB_датачас. Таким чином користувач зможе розуміти, яка резервна копія найновіша чи найстаріша. Також це допоможе у ситуації, якщо потрібна резервна копія за певну дату.
 
Рисунок 7.4.43 – Сторінка управління даними системи

При натисканні на кнопку «Make database backup» користувач повинен трохи зачекати, поки не буде виведено повідомлення про успішне створення резервної копії бази даних (див. рис. 7.4.44). Після цього створена резервна копія з’явиться серед списку усіх копій. 

 
Рисунок 7.4.44 – Повідомлення про успішне створення резервної копії бази даних
При натисканні на «Restore» біля назви певного файлу резервної копії бази даних, вона буде відновлена та виведеться повідомлення про успішне відновлення бази даних (див. рис. 7.4.45).

 
Рисунок 7.4.45 – Повідомлення про успішне відновлення бази даних

Це увесь функціонал для адміністратора системи. Натиснувши на «Log out» («Вийти» для української локалізації), користувач знов опиниться на сторінці входу до особистого акаунту. Увійдемо за логіном та паролем помічника і опинимось на сторінці з особистою інформацією про працівника (див. рис. 7.4.46).

 
Рисунок 7.4.46 – Вікно особистої інформації працівника закладу
Для зміни своєї особистої інформації користувач повинен натиснути на кнопку «Edit» і з’являться поля для вводу, заповнені актуальною інформацією. Для збереження змін слід натиснути на кнопку «Save» (див. рис. 7.4.47).

 
Рисунок 7.4.47 – Зміна особистої інформації працівника

При натисканні на «Orders» («Замовлення» для української локалізації) користувач опиниться на сторінці роботи з замовленнями (див. рис. 7.4.48). На відміну від адміністратора, працівники не можуть видаляти замовлення, тому доступна лише кнопка «Edit» біля кожного замовлення.
 
Рисунок 7.4.48 – Сторінка роботи з замовленнями

При натисканні на «Tables» у боковому меню сторінки, користувач перейде на сторінку управління столами (див. рис. 7.4.49). Усі додаткові кнопки цієї сторінки працюють аналогічно функціоналу на сторінці адміністратора.

 
Рисунок 7.4.49 – Сторінка роботи зі столами
При натисканні на «Schedule» у боковому меню сторінки, користувач перейде на сторінку управління своїм розкладом (див. рис. 7.4.50). Тут авторизований користувач може додавати собі нові робочі зміни натиснувши на кнопку «Add New». 

 
Рисунок 7.4.50 – Сторінка роботи з своїм розкладом

Для додавання нової зміни треба завомнити форму(див. Рис. 7.4.51).

 
Рисунок 7.4.51 –  Обрання дати та часу для кінця нової робочої зміни
Для обрання дати та часу при додаванні нової зміни також використовувався календар Слід зауважити, що випадний список для обрання співробітника заблоковано, бо у авторизованого користувача є можливість додавати нові робочі зміни лише собі.
При успішному додаванні нової робочої зміни працівнику буде виведено про це повідомлення (див. рис. 7.4.52).

 
Рисунок 7.4.52 – Повідомлення про успішне додавання нової робочої зміни

При обранні «Menu» у боковому меню сторінки, користувач перейде до перегляду меню закладу (див. рис.7.4.53).

 
Рисунок 7.4.53 – Сторінка зі стравами та напоями закладу

На відміну від адміністратора, користувач не може додавати, видаляти чи заміновати страви та напої. Але йому теж доступне сортування за типом страв. Вивід лише напоїв зображено на малюнку 7.4.54. 

 
Рисунок 7.4.54 – Результат фільтрації за фільтром «Напої»

Вивід списку виключно перших страв зображено на рисунку 7.4.55)

 
Рисунок 7.4.55 – Результат фільтрації за фільтром «Перші страви»


7.5	Опис програмної реалізації мобільного застосунку


Спочатку користувач повинен авторизуватися, увійшовши у свій особистий акаунт. Для цього на екрані входу до системи він повинен ввести свій логін та пароль (див. рис. 7.5.1). Також на цьому екрані наявна кнопка для реєстрації нових користувачів.

 
Рисунок 7.5.1 – Вхід до системи (англійська локалізація)

Також для мобільного застосунку присутня локалізація для англійської та української мови. Для того, щоб змінити мову застосунку цього необхідно змінити системну мову на смартфоні у налаштуваннях пристрою. Після цього знов відкрити застосунок. Після цих дій інтерфейс усіх екранів застосунку буде змінено на системну мову. На рисунку 7.5.2 наведено екран реєстрації з українською локалізацією.

 
Рисунок 7.5.2 – Вхід до системи (українська локалізація)

Після успішного входу до свого аканту користувач потрапляє на екран з його особистою інформацією (див. рис. 7.5.3). 
Внизу наявне меню для навігацією між екранами у застосунку (особистий акаунт, бронювання та меню закладу). 

 
Рисунок 7.5.3 – Перегляд особистої інформації про користувача

За бажанням користувач може змінювати свою особисту інформацію. Для цього йому необхідно змінити те, що він хоче і натиснути на кнопку «save» (або «зберегти» для української локалізації). Приклад зміни заповнення полів особистої інформації наведено на рисунку 7.5.4.

 
Рисунок 7.5.4 – Зміна особистої інформації про користувача у полях вводу

Було введено тестові дані для перевірки відображення зміни полів. Після натискання на кнопку збереження та за умови коректності введених даних ми отримаємо повідомлення про успішне оновлення інформації про користувача (див. рис. 7.5.5).

 
Рисунок 7.5.5 – Результат успішної зміни інформації про користувача

Також на екрані присутня друга кнопка – get coupon (отримати купон для української локалізації). При натисканні на неї, бонуси отримані користувачем будуть конвертовані у купон на знижку (див. рис. 7.5.6). Використовуються спеціальні математичні розрахунки, щоб дотримуватися принципу «більше бонусів – більше знижка».

 
Рисунок 7.5.6 – Результат успішного отримання купону

Якщо кількість бонусів недостатня для отримання знижки – буде виведено повідомлення про отримання знижки на 0 бонусів. 

Кількість наявних бонусів при цьому не буде змінена і залишиться такою самою, як була до спроби створення купону для бонусів (див. рис. 7.5.7).

 
Рисунок 7.5.7 – Результат невдалого отримання купону

Бачимо повідомлення про те, що гостя було оновлено, але дані залишились незмінні, бо балів на купон недостатньо. 
При натисканні у нижньому меню на кнопку Menu («Меню» для української локалізації) з іконкою книжки, користувач перейде на екран меню, де відображається список усіх страв та напоїв з інформацією про них (див. рис. 7.5.8).

 
Рисунок 7.5.8 – Екран меню закладу

Як бачимо, інформація про усі страви та напої відображається правильно. 
При натисканні на кнопку («Бронювання» для української локалізації), користувач перейде до екрану його бронювань. Тут він може керувати своїми бронюваннями та створювати нові (див. рис. 7.5.9).

 
Рисунок 7.5.9 – Екран бронювань користувача

Для створення нового бронювання для авторизованого користувача він повинен скористатися кнопкою «+» у правому нижньому кутку екрану бронювань. При натисканні на кнопку «+» користувач переходить на діалогове вікно створення нового бронювання. Тут йому необхідно ввести усю необхідну інформацію про бронювання (див. рис. 7.5.10).
 
Рисунок 7.5.10 – Діалогове вікно створення нового бронювання

Спершу користувач повинен вказати номер столу, за яким він хоче сидіти. Для цього у нього є спеціальний випадний список, який зображено на рисунку 7.5.11.

 
Рисунок 7.5.11 – Випадний список для обрання номеру столу бронювання
Потім користувач повинен ввести кількість людей, які прийдуть до закладу за цим бронюванням (наприклад прийде сімейна пара – 2 людини). Приклад введення кількості відвідувачів для бронювання наведено на малюнку 7.5.12.
 
Рисунок 7.5.12 – Введення кількості людей для бронювання

Потім користувач повинен обрати дату, на яку він хоче створити це бронювання. Для цього йому запропоновано календар, який автоматично виводить сьогоднішню дату. А користувач вже повинен обрати саме необхідну йому (див. рис. 7.5.13).

 
Рисунок 7.5.13 – Обрання дати для бронювання

Потім користувач повинен обрати час, на який він хоче створити це бронювання. Для цього йому запропоновано годинник, який автоматично виводить актуальний час. А користувач вже повинен обрати саме необхідну йому годину та хвилину (див. рис. 7.5.14).

 
Рисунок 7.5.14 – Обрання часу для бронювання

За бажанням користувач може додати якийсь коментар для свого бронювання, якщо хоче повідомити про щось персонал закладу (див. рис. 7.5.15). Рекомендовано вносити інформацію про особливі події, алергії чи побажання.
 
Рисунок 7.5.15 – Додатковий коментар до бронювання

Після цього користувач повинен натиснути на кнопку «Add Booking» («Додати бронювання» для української локалізації). Після цього створене бронювання з’явиться у списку бронювань користувача (див. рис. 7.5.16).

 
Рисунок 7.5.16 – Результат додавання нового бронювання
Як бачимо, біля кожного бронювання присутні кнопки «Delete» та «Update» («Видалити» та «Змінити» для української локалізації відповідно). Користувач для зміни інформації про бронювання, натискає на кнопку «Update», після чого відкривається діалогове вікно для зміни інформації про бронювання. (див. рис. 7.5.17).

 
Рисунок 7.5.17 – Приклад зміни інформації про бронювання користувача

Змінивши усю інформацію у полях вводу користувач для підтвердження оновлення даних повинен натиснути кнопку «Update Booking» («Змінити Бронювання» для української локалізації). Після цього у списку усіх бронювань відвідувача буде зображено оновлене бронювання (див. рис. 7.5.18). Також буде виведено системне повідомлення про успішне оновлення бронювання.

 
Рисунок 7.5.18 – Результат успішного оновлення даних про бронювання

При натисканні на кнопку «Delete» («Видалити» для української локалізації), бронювання буде видалено і внизу екрану виведено системне повідомлення про успішне видалення бронювання (див. рис. 7.5.19). Таким чином користувач може бути впевнений, що його бронювання дійсно відмінено.

 
Рисунок 7.5.19 – Результат успішного видалення бронювання

Якщо користувач ще немає особистого акаунту, то він повинен зареєструватися. Для цього він повинен ввести усі свої необхідні особисті дані та натиснути на кнопку «Register» («Зареєструвати обліковий запис» для української локалізації). Приклад реєстрації наведено на рисунку 7.5.20.

 
Рисунок 7.5.20 – Заповнена форма реєстрації користувача

Якщо перевести систему мобільного пристрою на українську мову, то екран реєстрації нового користувача буде переведено на українську мову (див. рис. 7.5.21).

Таким чином були переведені усі надписи у застосунку, включаючи підказки для вводу інформації у полях вводу.

 
Рисунок 7.5.21 – Екран реєстрації при українській локалізації

Після реєстрації нового користувача так само входимо у його особистий акаунт і потрапляємо на особисту сторінку (див. рис. 7.5.22). Як бачимо, бонусів ще не нараховано, бо користувач досі не створював нових бронювань та замовлень).

 
Рисунок 7.5.22 – Вікно особистої інформації нового користувача

Таким чином мобільний застосунок дозволяє користувачам створювати собі акаунт, авторизуватися за логіном та паролем, змінювати особисту інформацію, отримувати купони, дивитися меню, додавати нові бронювання, змінювати інформацію про вже існуючі та видаляти їх.


8	ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему для автоматизації управління закладами громадського харчування «Tastify». Демонстрацію програми можна подивитися за наступним посиланням (DEMO: https://www.youtube.com/watch?v=eRBhY0Bhw74)
У процесі роботи було досліджено предметну область, виконане концептуальне моделювання, розроблена база даних, серверна частина, вебзастосунок для працівників і адміністраторів та мобільний застосунок для відвідувачів закладів.
Розроблена програмна система надає можливість ресторанам оптимізувати кількість робочих процесів. «Tastify» спрощує роботу офіціантам, адміністраторам та іншим працівникам закладів громадського харчування. Після авторизації у системі вони отримують доступ до керування меню закладу, бронюваннями гостей, обліку харчових продуктів, робочих змін працівників, керування резервними копіями даних, тощо. Також відвідувачі закладів отримають більше відповідальності і можуть самі керувати своїми бронюваннями, переглядати меню на своєму мобільному пристрої та брати участь у бонусній програмі.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	 MongoDB 7.0 Manual. MongoDB: The Developer Data Platform. URL: https://www.mongodb.com/docs/manual/ (дата звернення: 28.04.2024).
2.	ASP.NET documentation. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 28.04.2024).
3.	JavaScript documentation. MDN Web Docs: Resources for Developers, by Developers. URL: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference (дата звернення: 28.04.2024).
4.	Kotlin 2.0.0 Docs. Kotlin Programming Language: Official Documentation. URL: https://kotlinlang.org/docs/home.html (дата звернення 28.04.2024).


ДОДАТОК А
Діаграми програмної системи

 
Рисунок А.1 – Діаграма станів для адміністратора закладу громадського харчування програмної системи «Tastify»
 
Рисунок А.2 – Діаграма станів для працівника закладу громадського харчування програмної системи «Tastify»
 
Рисунок А.3 – Діаграма станів для відвідувача закладу громадського харчування програмної системи «Tastify»
 
Рисунок А.4 – UML діаграма компонент клієнтської частини програмної системи «Tastify»
 
Рисунок А.5 – Діаграма компонент громадського харчування мобільної частини програмної системи «Tastify»


ДОДАТОК Б
Програмний код системи
Б.1 Код StaffService.cs, для роботи з колекціями працівників: 


1 public class StaffService 
2 { 
3 private readonly IMongoCollection<Staff> _staffCollection; 
4 private readonly IMongoCollection<Schedule> _scheduleCollection; 
5 private readonly ILogger<StaffService> _logger; 
6 
7 public StaffService(IMongoDatabase database, IMongoCollection<Schedule> scheduleCollection, ILogger<StaffService> logger) 
8 { 
9 _staffCollection = database.GetCollection<Staff>("Staff"); 
10 _scheduleCollection = database.GetCollection<Schedule>("Schedule"); 
11 _logger = logger; 
12 } 
13 
14 public async Task<List<Staff>> GetAsync() => 
15 await _staffCollection.Find(_ => true).ToListAsync(); 
16 
17 public async Task<Staff> GetByIdAsync(string id) => 
18 await _staffCollection.Find(x => x.Id == id).FirstOrDefaultAsync(); 
19 
20 public async Task CreateAsync(Staff staff) => 
21 await _staffCollection.InsertOneAsync(staff); 
22 
23 public async Task UpdateAsync(string id, Staff updatedStaff) => 
24 await _staffCollection.ReplaceOneAsync(x => x.Id == id, updatedStaff); 
25 
26 public async Task RemoveAsync(string id) => 
27 await _staffCollection.DeleteOneAsync(x => x.Id == id); 
28 
29 public async Task<bool> AnyAsync(Expression<Func<Staff, bool>> filter) => 
30 await _staffCollection.Find(filter).AnyAsync(); 
31 
32 public async Task<Staff> GetByLoginAsync(string login) => 
33 await _staffCollection.Find(x => x.Login == login).FirstOrDefaultAsync(); 
34 
35 public async Task<List<StaffReportDto>> GetWeeklyWorkingHoursAsync(DateTime startDate) 
36 { 
37 var endDate = startDate.AddDays(6).Date.AddHours(23).AddMinutes(59).AddSeconds(59); 
38 
39 var result = new List<StaffReportDto>(); 
40 
41 var staffList = await _staffCollection.Find(_ => true).ToListAsync(); 
42 
43 _logger.LogInformation($"Found {staffList.Count} staff members"); 
44 
45 foreach (var staff in staffList) 
46 { 
47 var staffReport = new StaffReportDto 
48 { 
49 Name = staff.Name, 
50 TotalWorkingHours = 0 
51 }; 
52 
53 var scheduleList = await _scheduleCollection.Find(x => x.StaffId == staff.Id && x.StartDateTime >= startDate && x.FinishDateTime <= endDate).ToListAsync(); 
54 
55 foreach (var schedule in scheduleList) 
56 { 
57 if (schedule.FinishDateTime.HasValue && schedule.StartDateTime.HasValue) 
58 { 
59 var hours = (schedule.FinishDateTime.Value - schedule.StartDateTime.Value).TotalHours; 
60 staffReport.TotalWorkingHours += hours; 
61 } 
62 } 
63 
64 _logger.LogInformation($"Total working hours for {staffReport.Name}: {staffReport.TotalWorkingHours}"); 
65 
66 result.Add(staffReport); 
67 } 
68 
69 return result; 
70 } 
71 }


Б.2 Код Tables.js, для роботи зі столами закладу:


1	document.addEventListener('DOMContentLoaded', async function () {
2	    const apiUrl = 'https://localhost:7206/api/Table/';
3	    const tablesTableBody = document.querySelector('#tables-table tbody');
4	    const addButton = document.querySelector('.btn-add');
5	
6	    const getToken = () => localStorage.getItem('token');
7	
8	    const fetchTables = async () => {
9	        try {
10	            const response = await fetch(apiUrl, {
11	                headers: {
12	                    'Authorization': `Bearer ${getToken()}`,
13	                    'Content-Type': 'application/json'
14	                }
15	            });
16	
17	            if (response.ok) {
18	                const tables = await response.json();
19	                displayTables(Array.isArray(tables) ? tables : []);
20	            } else {
21	                console.error('Error:', await response.text());
22	            }
23	        } catch (error) {
24	            console.error('Error:', error.message);
25	        }
26	    };
27	
28	    const displayTables = (tables) => {
29	        tablesTableBody.innerHTML = '';
30	        tables.forEach(table => {
31	            const row = document.createElement('tr');
32	            row.innerHTML = `
33	                <td>${table.number}</td>
34	                <td>${table.status}</td>
35	                <td><button class="btn-edit" data-tableid="${table.id}">Edit</button></td>
36	                <td><button class="btn-delete" data-tableid="${table.id}">Delete</button></td>
37	            `;
38	            tablesTableBody.appendChild(row);
39	        });
40	    };
41	
42	    const handleDelete = async (tableId) => {
43	        if (!tableId) return console.error('Error: Table ID is undefined');
44	        try {
45	            const response = await fetch(`${apiUrl}${tableId}`, {
46	                method: 'DELETE',
47	                headers: {
48	                    'Authorization': `Bearer ${getToken()}`,
49	                    'Content-Type': 'application/json'
50	                }
51	            });
52	
53	            if (response.ok) {
54	                alert('Table was deleted successfully!');
55	                await fetchTables();
56	            } else {
57	                console.error('Error:', await response.text());
58	            }
59	        } catch (error) {
60	            console.error('Error:', error.message);
61	        }
62	    };
63	
64	    const handleEdit = (tableId) => {
65	        if (!tableId) return console.error('Error: Table ID is undefined');
66	        const row = document.querySelector(`button[data-tableid="${tableId}"]`).closest('tr');
67	        const [numberCell, statusCell] = row.cells;
68	
69	        numberCell.innerHTML = `<input type="text" value="${numberCell.textContent}">`;
70	        statusCell.innerHTML = `<input type="text" value="${statusCell.textContent}">`;
71	        row.cells[2].innerHTML = `<button class="btn-save" data-tableid="${tableId}">Save</button>`;
72	        row.cells[3].innerHTML = `<button class="btn-cancel" data-tableid="${tableId}">Cancel</button>`;
73	    };
74	
75	    const handleSave = async (tableId) => {
76	        if (!tableId) return console.error('Error: Table ID is undefined');
77	        const row = document.querySelector(`button[data-tableid="${tableId}"]`).closest('tr');
78	        const number = row.cells[0].querySelector('input').value;
79	        const status = row.cells[1].querySelector('input').value;
80	
81	        if (!number || !status) {
82	            alert('Please fill in all fields');
83	            return;
84	        }
85	
86	        try {
87	            const response = await fetch(`${apiUrl}${tableId}`, {
88	                method: 'PUT',
89	                headers: {
90	                    'Authorization': `Bearer ${getToken()}`,
91	                    'Content-Type': 'application/json'
92	                },
93	                body: JSON.stringify({ number, status })
94	            });
95	
96	            if (response.ok) {
97	                alert('Table was updated successfully!');
98	                await fetchTables();
99	            } else {
100	                console.error('Error:', await response.json());
101	            }
102	        } catch (error) {
103	            console.error('Error:', error.message);
104	        }
105	    };
106	
107	    const handleCancel = async () => {
108	        await fetchTables();
109	    };
110	
111	    const handleAdd = async () => {
112	        const number = document.getElementById('input-number').value;
113	        const status = document.getElementById('input-status').value;
114	
115	        if (!number || !status) {
116	            alert('Please fill in all fields');
117	            return;
118	        }
119	
120	        try {
121	            const response = await fetch(apiUrl, {
122	                method: 'POST',
123	                headers: {
124	                    'Authorization': `Bearer ${getToken()}`,
125	                    'Content-Type': 'application/json'
126	                },
127	                body: JSON.stringify({ number, status })
128	            });
129	
130	            if (response.ok) {
131	                alert('Table was added successfully!');
132	                await fetchTables();
133	            } else {
134	                console.error('Error:', await response.text());
135	            }
136	        } catch (error) {
137	            console.error('Error:', error.message);
138	        }
139	    };
140	
141	    // Event delegation for dynamic buttons
142	    tablesTableBody.addEventListener('click', async (event) => {
143	        const { target } = event;
144	        const tableId = target.getAttribute('data-tableid');
145	
146	        if (target.classList.contains('btn-delete')) {
147	            await handleDelete(tableId);
148	        } else if (target.classList.contains('btn-edit')) {
149	            handleEdit(tableId);
150	        } else if (target.classList.contains('btn-save')) {
151	            await handleSave(tableId);
152	        } else if (target.classList.contains('btn-cancel')) {
153	            await handleCancel();
154	        }
155	    });
156	
157	    // Add button event listener
158	    addButton.addEventListener('click', handleAdd);
159	
160	    // Fetch tables initially
161	    await fetchTables();
162	});


Б.3 Код BookingsActivity.kt:


1	package com.example.tastifymobile.activities
2	
3	import android.app.DatePickerDialog
4	import android.app.TimePickerDialog
5	import android.os.Bundle
6	import android.util.Log
7	import android.view.LayoutInflater
8	import android.widget.ArrayAdapter
9	import android.widget.Button
10	import android.widget.EditText
11	import android.widget.Spinner
12	import android.widget.Toast
13	import androidx.appcompat.app.AlertDialog
14	import androidx.appcompat.app.AppCompatActivity
15	import androidx.recyclerview.widget.LinearLayoutManager
16	import androidx.recyclerview.widget.RecyclerView
17	import com.example.tastifymobile.R
18	import com.example.tastifymobile.adapters.BookingsAdapter
19	import com.example.tastifymobile.api.NetworkModule
20	import com.example.tastifymobile.api.TokenManager
21	import com.example.tastifymobile.models.Booking
22	import com.example.tastifymobile.models.Table
23	import com.example.tastifymobile.services.BookingsService
24	import com.example.tastifymobile.utils.NavigationUtil
25	import com.google.android.material.bottomnavigation.BottomNavigationView
26	import java.text.SimpleDateFormat
27	import java.util.*
28	
29	class BookingsActivity : AppCompatActivity() {
30	
31	    private lateinit var bookingsService: BookingsService
32	    private lateinit var bookingsAdapter: BookingsAdapter
33	    private lateinit var recyclerView: RecyclerView
34	    private lateinit var tokenManager: TokenManager
35	    private var guestId: String? = null
36	
37	    override fun onCreate(savedInstanceState: Bundle?) {
38	        super.onCreate(savedInstanceState)
39	        setContentView(R.layout.activity_bookings)
40	
41	        val apiService = NetworkModule.provideApiService(this)
42	        bookingsService = BookingsService(apiService)
43	
44	        val bottomNavMenu = findViewById<BottomNavigationView>(R.id.bottom_navigation)
45	        NavigationUtil.setupBottomMenu(bottomNavMenu, this)
46	        bottomNavMenu.menu.findItem(R.id.profile).isChecked = true
47	
48	        recyclerView = findViewById(R.id.recyclerViewBookings)
49	        recyclerView.layoutManager = LinearLayoutManager(this)
50	
51	        tokenManager = TokenManager(this)
52	        guestId = tokenManager.getGuestIdFromToken()
53	
54	        fetchBookings()
55	
56	        val addBookingButton: Button = findViewById(R.id.addBookingButton)
57	        addBookingButton.setOnClickListener {
58	            showAddBookingDialog()
59	        }
60	    }
61	
62	    private fun fetchBookings() {
63	        bookingsService.fetchBookings(guestId!!, { bookings ->
64	            bookingsAdapter = BookingsAdapter(this, bookings, bookingsService, { deletedBooking ->
65	                Toast.makeText(this, getResources().getString(R.string.booking_deleted), Toast.LENGTH_SHORT).show()
66	                fetchBookings() // Refresh bookings after deletion
67	            }, { updatedBooking ->
68	                Toast.makeText(this, getResources().getString(R.string.booking_updated), Toast.LENGTH_SHORT).show()
69	                fetchBookings() // Refresh bookings after update
70	            })
71	            recyclerView.adapter = bookingsAdapter
72	        }, { errorMessage ->
73	            Log.e("BookingsActivity", errorMessage)
74	            Toast.makeText(this, errorMessage, Toast.LENGTH_SHORT).show()
75	        })
76	    }
77	
78	    private fun showAddBookingDialog() {
79	        bookingsService.fetchTables({ tables ->
80	            val builder = AlertDialog.Builder(this)
81	            val inflater = LayoutInflater.from(this)
82	            val dialogView = inflater.inflate(R.layout.dialog_add_booking, null)
83	            builder.setView(dialogView)
84	
85	            val dialog = builder.create()
86	            dialog.show()
87	
88	            val spinnerTableId = dialogView.findViewById<Spinner>(R.id.spinnerTableId)
89	            val editTextPersonsCount = dialogView.findViewById<EditText>(R.id.editTextPersonsCount)
90	            val editTextComment = dialogView.findViewById<EditText>(R.id.editTextComment)
91	            val btnAddBooking = dialogView.findViewById<Button>(R.id.btnAddBooking)
92	            val editTextBookingDate = dialogView.findViewById<EditText>(R.id.editTextBookingDate)
93	            val editTextBookingTime = dialogView.findViewById<EditText>(R.id.editTextBookingTime)
94	
95	            val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
96	            val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())
97	
98	            // Set up the spinner with table numbers
99	            val tableNumbers = tables.map { it.number.toString() }
100	            val adapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, tableNumbers)
101	            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
102	            spinnerTableId.adapter = adapter
103	
104	            editTextBookingDate.setOnClickListener {
105	                val calendar = Calendar.getInstance()
106	                val dateSetListener = DatePickerDialog.OnDateSetListener { _, year, month, dayOfMonth ->
107	                    val selectedDate = Calendar.getInstance()
108	                    selectedDate.set(year, month, dayOfMonth)
109	                    editTextBookingDate.setText(dateFormat.format(selectedDate.time))
110	                }
111	
112	                DatePickerDialog(
113	                    this,
114	                    dateSetListener,
115	                    calendar.get(Calendar.YEAR),
116	                    calendar.get(Calendar.MONTH),
117	                    calendar.get(Calendar.DAY_OF_MONTH)
118	                ).show()
119	            }
120	
121	            editTextBookingTime.setOnClickListener {
122	                val calendar = Calendar.getInstance()
123	                val timeSetListener = TimePickerDialog.OnTimeSetListener { _, hourOfDay, minute ->
124	                    val selectedTime = Calendar.getInstance()
125	                    selectedTime.set(Calendar.HOUR_OF_DAY, hourOfDay)
126	                    selectedTime.set(Calendar.MINUTE, minute)
127	                    editTextBookingTime.setText(timeFormat.format(selectedTime.time))
128	                }
129	
130	                TimePickerDialog(
131	                    this,
132	                    timeSetListener,
133	                    calendar.get(Calendar.HOUR_OF_DAY),
134	                    calendar.get(Calendar.MINUTE),
135	                    true
136	                ).show()
137	            }
138	
139	            btnAddBooking.setOnClickListener {
140	                val selectedTableNumber = spinnerTableId.selectedItem.toString().toIntOrNull()
141	                val personsCount = editTextPersonsCount.text.toString().toIntOrNull()
142	                val comment = editTextComment.text.toString()
143	                val bookingDateStr = editTextBookingDate.text.toString()
144	                val bookingTimeStr = editTextBookingTime.text.toString()
145	
146	                if (selectedTableNumber != null && personsCount != null && personsCount > 0 && guestId != null) {
147	                    val selectedTable = tables.find { it.number == selectedTableNumber }
148	
149	                    val bookingDate = dateFormat.parse(bookingDateStr)
150	                    val bookingTime = timeFormat.parse(bookingTimeStr)
151	                    val calendar = Calendar.getInstance()
152	                    calendar.time = bookingDate
153	                    calendar.set(Calendar.HOUR_OF_DAY, bookingTime.hours)
154	                    calendar.set(Calendar.MINUTE, bookingTime.minutes)
155	
156	                    val newBooking = Booking(
157	                        id = null,
158	                        tableId = selectedTable?.id,
159	                        guestId = guestId,
160	                        bookingDateTime = calendar.time,
161	                        personsCount = personsCount,
162	                        comment = comment
163	                    )
164	
165	                    bookingsService.createBooking(newBooking, {
166	                        dialog.dismiss()
167	                        fetchBookings()
168	                    }, { errorMessage ->
169	                        Toast.makeText(this, "Failed to create booking: $errorMessage", Toast.LENGTH_SHORT).show()
170	                    })
171	                } else {
172	                    Toast.makeText(this, "Invalid input for creating booking", Toast.LENGTH_SHORT).show()
173	                }
174	            }
175	        }, { errorMessage ->
176	            Toast.makeText(this, "Failed to load tables: $errorMessage", Toast.LENGTH_SHORT).show()
177	        })
178	    }
179	}


Б.4 Код BookingsAdapter.kt:


1	package com.example.tastifymobile.adapters
2	
3	import android.app.AlertDialog
4	import android.app.DatePickerDialog
5	import android.app.TimePickerDialog
6	import android.content.Context
7	import android.util.Log
8	import android.view.LayoutInflater
9	import android.view.View
10	import android.view.ViewGroup
11	import android.widget.Button
12	import android.widget.EditText
13	import android.widget.TextView
14	import androidx.recyclerview.widget.RecyclerView
15	import com.example.tastifymobile.R
16	import com.example.tastifymobile.api.ApiService
17	import com.example.tastifymobile.api.NetworkModule
18	import com.example.tastifymobile.models.Booking
19	import com.example.tastifymobile.models.Table
20	import com.example.tastifymobile.services.BookingsService
21	import retrofit2.Call
22	import retrofit2.Callback
23	import retrofit2.Response
24	import java.text.SimpleDateFormat
25	import java.util.*
26	
27	class BookingsAdapter(
28	    private val context: Context,
29	    private val bookings: List<Booking>,
30	    private val bookingsService: BookingsService,
31	    private val onBookingDeleted: (Booking) -> Unit,
32	    private val onBookingUpdated: (Booking) -> Unit
33	) : RecyclerView.Adapter<BookingsAdapter.BookingViewHolder>() {
34	
35	    private val apiService: ApiService = NetworkModule.provideApiService(context)
36	
37	    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BookingViewHolder {
38	        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_booking, parent, false)
39	        return BookingViewHolder(view)
40	    }
41	
42	    override fun onBindViewHolder(holder: BookingViewHolder, position: Int) {
43	        val booking = bookings[position]
44	
45	        booking.tableId?.let { fetchTableNumber(it, holder.tableNumberTextView) }
46	
47	        holder.bookingDateTimeTextView.text = SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault()).format(booking.bookingDateTime)
48	        holder.personsCountTextView.text = booking.personsCount.toString()
49	        holder.commentTextView.text = booking.comment
50	
51	        holder.deleteButton.setOnClickListener {
52	            bookingsService.deleteBooking(booking.id!!, {
53	                onBookingDeleted(booking)
54	            }, { errorMessage ->
55	                Log.e("BookingsAdapter", errorMessage)
56	            })
57	        }
58	
59	        holder.updateButton.setOnClickListener {
60	            showUpdateBookingDialog(holder, booking)
61	        }
62	    }
63	
64	    override fun getItemCount(): Int {
65	        return bookings.size
66	    }
67	
68	    private fun fetchTableNumber(tableId: String, tableNumberTextView: TextView) {
69	        apiService.getTableById(tableId).enqueue(object : Callback<Table> {
70	            override fun onResponse(call: Call<Table>, response: Response<Table>) {
71	                if (response.isSuccessful) {
72	                    val table = response.body()
73	                    if (table != null) {
74	                        tableNumberTextView.text = "Table Number: ${table.number}"
75	                    } else {
76	                        Log.e("BookingsAdapter", "Failed to retrieve table data")
77	                        tableNumberTextView.text = "Table ID: $tableId"
78	                    }
79	                } else {
80	                    Log.e("BookingsAdapter", "Failed to retrieve table data: ${response.message()}")
81	                    tableNumberTextView.text = "Table ID: $tableId"
82	                }
83	            }
84	
85	            override fun onFailure(call: Call<Table>, t: Throwable) {
86	                Log.e("BookingsAdapter", "Error fetching table data: ${t.message}")
87	                tableNumberTextView.text = "Table ID: $tableId"
88	            }
89	        })
90	    }
91	
92	    private fun showUpdateBookingDialog(holder: BookingViewHolder, booking: Booking) {
93	        val builder = AlertDialog.Builder(holder.itemView.context)
94	        val inflater = LayoutInflater.from(holder.itemView.context)
95	        val dialogView = inflater.inflate(R.layout.dialog_update_booking, null)
96	        builder.setView(dialogView)
97	
98	        val dialog = builder.create()
99	        dialog.show()
100	
101	        val editTextPersonsCount = dialogView.findViewById<EditText>(R.id.editTextPersonsCount)
102	        val editTextComment = dialogView.findViewById<EditText>(R.id.editTextComment)
103	        val editTextBookingDate = dialogView.findViewById<EditText>(R.id.editTextBookingDate)
104	        val editTextBookingTime = dialogView.findViewById<EditText>(R.id.editTextBookingTime)
105	        val btnUpdateBooking = dialogView.findViewById<Button>(R.id.btnUpdateBooking)
106	
107	        editTextPersonsCount.setText(booking.personsCount.toString())
108	        editTextComment.setText(booking.comment)
109	
110	        val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
111	        val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())
112	
113	        // Set current booking date and time
114	        editTextBookingDate.setText(dateFormat.format(booking.bookingDateTime))
115	        editTextBookingTime.setText(timeFormat.format(booking.bookingDateTime))
116	
117	        // Date picker logic
118	        editTextBookingDate.setOnClickListener {
119	            val calendar = Calendar.getInstance()
120	            val dateSetListener = DatePickerDialog.OnDateSetListener { _, year, month, dayOfMonth ->
121	                val selectedDate = Calendar.getInstance()
122	                selectedDate.set(year, month, dayOfMonth)
123	                editTextBookingDate.setText(dateFormat.format(selectedDate.time))
124	            }
125	
126	            DatePickerDialog(
127	                holder.itemView.context,
128	                dateSetListener,
129	                calendar.get(Calendar.YEAR),
130	                calendar.get(Calendar.MONTH),
131	                calendar.get(Calendar.DAY_OF_MONTH)
132	            ).show()
133	        }
134	
135	        // Time picker logic
136	        editTextBookingTime.setOnClickListener {
137	            val calendar = Calendar.getInstance()
138	            val timeSetListener = TimePickerDialog.OnTimeSetListener { _, hour, minute ->
139	                val selectedTime = Calendar.getInstance()
140	                selectedTime.set(Calendar.HOUR_OF_DAY, hour)
141	                selectedTime.set(Calendar.MINUTE, minute)
142	                editTextBookingTime.setText(timeFormat.format(selectedTime.time))
143	            }
144	
145	            TimePickerDialog(
146	                holder.itemView.context,
147	                timeSetListener,
148	                calendar.get(Calendar.HOUR_OF_DAY),
149	                calendar.get(Calendar.MINUTE),
150	                true
151	            ).show()
152	        }
153	
154	        btnUpdateBooking.setOnClickListener {
155	            val updatedPersonsCount = editTextPersonsCount.text.toString().toInt()
156	            val updatedComment = editTextComment.text.toString()
157	            val updatedBookingDate = dateFormat.parse(editTextBookingDate.text.toString())
158	            val updatedBookingTime = timeFormat.parse(editTextBookingTime.text.toString())
159	
160	            if (updatedBookingDate != null && updatedBookingTime != null) {
161	                val calendar = Calendar.getInstance()
162	                calendar.time = updatedBookingDate
163	                val bookingCalendar = Calendar.getInstance()
164	                bookingCalendar.time = updatedBookingTime
165	                calendar.set(Calendar.HOUR_OF_DAY, bookingCalendar.get(Calendar.HOUR_OF_DAY))
166	                calendar.set(Calendar.MINUTE, bookingCalendar.get(Calendar.MINUTE))
167	
168	                val updatedBooking = Booking(
169	                    id = booking.id,
170	                    tableId = booking.tableId,
171	                    bookingDateTime = calendar.time,
172	                    personsCount = updatedPersonsCount,
173	                    comment = updatedComment,
174	                    guestId = booking.guestId
175	                )
176	
177	                bookingsService.updateBooking(updatedBooking.id!!, updatedBooking, {
178	                    onBookingUpdated(updatedBooking)
179	                    dialog.dismiss()
180	                }, { errorMessage ->
181	                    Log.e("BookingsAdapter", errorMessage)
182	                })
183	            }
184	        }
185	    }
186	
187	    class BookingViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
188	        val tableNumberTextView: TextView = itemView.findViewById(R.id.tableNumberTextView)
189	        val bookingDateTimeTextView: TextView = itemView.findViewById(R.id.bookingDateTimeTextView)
190	        val personsCountTextView: TextView = itemView.findViewById(R.id.personsCountTextView)
191	        val commentTextView: TextView = itemView.findViewById(R.id.commentTextView)
192	        val deleteButton: Button = itemView.findViewById(R.id.deleteBookingButton)
193	        val updateButton: Button = itemView.findViewById(R.id.updateBookingButton)
194	    }
195	
196	
197	}


Б.5 Код BookingsService.kt:


1	package com.example.tastifymobile.services
2	
3	import android.util.Log
4	import android.widget.Toast
5	import com.example.tastifymobile.api.ApiService
6	import com.example.tastifymobile.models.Booking
7	import com.example.tastifymobile.models.Table
8	import okhttp3.ResponseBody
9	import retrofit2.Call
10	import retrofit2.Callback
11	import retrofit2.Response
12	
13	class BookingsService(val apiService: ApiService) {
14	
15	    fun fetchBookings(guestId: String, onResult: (List<Booking>) -> Unit, onError: (String) -> Unit) {
16	        apiService.getAllBookingsByGuestId(guestId).enqueue(object : Callback<List<Booking>> {
17	            override fun onResponse(call: Call<List<Booking>>, response: Response<List<Booking>>) {
18	                if (response.isSuccessful) {
19	                    val bookings = response.body() ?: emptyList()
20	                    onResult(bookings)
21	                } else {
22	                    onError("Failed to load bookings: ${response.message()}")
23	                }
24	            }
25	
26	            override fun onFailure(call: Call<List<Booking>>, t: Throwable) {
27	                onError("Error fetching bookings: ${t.message}")
28	            }
29	        })
30	    }
31	
32	    fun fetchTables(onTablesFetched: (List<Table>) -> Unit, onError: (String) -> Unit) {
33	        apiService.getTables().enqueue(object : Callback<List<Table>> {
34	            override fun onResponse(call: Call<List<Table>>, response: Response<List<Table>>) {
35	                if (response.isSuccessful) {
36	                    val tables = response.body() ?: emptyList()
37	                    onTablesFetched(tables)
38	                } else {
39	                    onError("Failed to load tables: ${response.message()}")
40	                }
41	            }
42	
43	            override fun onFailure(call: Call<List<Table>>, t: Throwable) {
44	                onError("Error fetching tables: ${t.message}")
45	            }
46	        })
47	    }
48	
49	    fun createBooking(newBooking: Booking, onSuccess: () -> Unit, onError: (String) -> Unit) {
50	        apiService.createBooking(newBooking).enqueue(object : Callback<ResponseBody> {
51	            override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {
52	                if (response.isSuccessful) {
53	                    onSuccess()
54	                } else {
55	                    onError("Failed to create booking: ${response.message()}")
56	                }
57	            }
58	
59	            override fun onFailure(call: Call<ResponseBody>, t: Throwable) {
60	                onError("Error creating booking: ${t.message}")
61	            }
62	        })
63	    }
64	
65	    fun deleteBooking(bookingId: String, onSuccess: () -> Unit, onError: (String) -> Unit) {
66	        apiService.deleteBooking(bookingId).enqueue(object : Callback<Void> {
67	            override fun onResponse(call: Call<Void>, response: Response<Void>) {
68	                if (response.isSuccessful) {
69	                    onSuccess()
70	                } else {
71	                    onError("Failed to delete booking: ${response.message()}")
72	                }
73	            }
74	
75	            override fun onFailure(call: Call<Void>, t: Throwable) {
76	                onError("Error deleting booking: ${t.message}")
77	            }
78	        })
79	    }
80	
81	    fun updateBooking(bookingId: String, updatedBooking: Booking, onSuccess: () -> Unit, onError: (String) -> Unit) {
82	        apiService.updateBooking(bookingId, updatedBooking).enqueue(object : Callback<Void> {
83	            override fun onResponse(call: Call<Void>, response: Response<Void>) {
84	                if (response.isSuccessful) {
85	                    onSuccess()
86	                } else {
87	                    onError("Failed to update booking: ${response.message()}")
88	                }
89	            }
90	
91	            override fun onFailure(call: Call<Void>, t: Throwable) {
92	                onError("Error updating booking: ${t.message}")
93	            }
94	        })
95	    }
96	}

